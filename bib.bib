@article{00000539-201805000-00050,
	title        = {Correlation Coefficients: Appropriate Use and Interpretation},
	author       = {Schober, Patrick and Boer, Christa and Schwarte, Lothar A.},
	year         = 2018,
	journal      = {Anesthesia {\&} Analgesia},
	volume       = 126,
	number       = 5,
	issn         = {0003-2999},
	url          = {https://journals.lww.com/anesthesia-analgesia/Fulltext/2018/05000/Correlation\%5FCoefficients\%5F\%5FAppropriate\%5FUse\%5Fand.50.aspx},
	abstract     = {Correlation in the broadest sense is a measure of an association between variables. In correlated data, the change in the magnitude of 1 variable is associated with a change in the magnitude of another variable, either in the same (positive correlation) or in the opposite (negative correlation) direction. Most often, the term correlation is used in the context of a linear relationship between 2 continuous variables and expressed as Pearson product-moment correlation. The Pearson correlation coefficient is typically used for jointly normally distributed data (data that follow a bivariate normal distribution). For nonnormally distributed continuous data, for ordinal data, or for data with relevant outliers, a Spearman rank correlation can be used as a measure of a monotonic association. Both correlation coefficients are scaled such that they range from --1 to +1, where 0 indicates that there is no linear or monotonic association, and the relationship gets stronger and ultimately approaches a straight line (Pearson correlation) or a constantly increasing or decreasing curve (Spearman correlation) as the coefficient approaches an absolute value of 1. Hypothesis tests and confidence intervals can be used to address the statistical significance of the results and to estimate the strength of the relationship in the population from which the data were sampled. The aim of this tutorial is to guide researchers and clinicians in the appropriate use and interpretation of correlation coefficients.}
}
@inproceedings{10.1007/3-540-49538-X_5,
	title        = {Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis},
	author       = {Dean, Jeffrey and Grove, David and Chambers, Craig},
	year         = 1995,
	booktitle    = {ECOOP'95 --- Object-Oriented Programming, 9th European Conference, {\AA}arhus, Denmark, August 7--11, 1995},
	publisher    = {Springer Berlin Heidelberg},
	address      = {Berlin, Heidelberg},
	pages        = {77--101},
	isbn         = {978-3-540-49538-3},
	editor       = {Tokoro, Mario and Pareschi, Remo},
	abstract     = {Optimizing compilers for object-oriented languages apply static class analysis and other techniques to try to deduce precise information about the possible classes of the receivers of messages; if successful, dynamically-dispatched messages can be replaced with direct procedure calls and potentially further optimized through inline-expansion. By examining the complete inheritance graph of a program, which we call class hierarchy analysis, the compiler can improve the quality of static class information and thereby improve run-time performance. In this paper we present class hierarchy analysis and describe techniques for implementing this analysis effectively in both statically- and dynamically-typed languages and also in the presence of multi-methods. We also discuss how class hierarchy analysis can be supported in an interactive programming environment and, to some extent, in the presence of separate compilation. Finally, we assess the bottom-line performance improvement due to class hierarchy analysis alone and in combination with two other ``competing'' optimizations, profile-guided receiver class prediction and method specialization.}
}
@inbook{10.1007/978-0-387-68768-1_4,
	title        = {Automatically Identifying Trigger-based Behavior in Malware},
	author       = {Brumley, David and Hartwig, Cody and Liang, Zhenkai and Newsome, James and Song, Dawn and Yin, Heng},
	year         = 2008,
	booktitle    = {Botnet Detection: Countering the Largest Security Threat},
	publisher    = {Springer US},
	address      = {Boston, MA},
	pages        = {65--88},
	doi          = {10.1007/978-0-387-68768-1_4},
	isbn         = {978-0-387-68768-1},
	url          = {https://doi.org/10.1007/978-0-387-68768-1\%5F4},
	abstract     = {Malware often contains hidden behavior which is only activated when properly triggered. Well known examples include: the MyDoom worm which DDoS's on particular dates, keyloggers which only log keystrokes for particular sites, and DDoS zombies which are only activated when given the proper command. We call such behavior trigger-based behavior}
}
@inproceedings{10.1007/978-3-030-01701-9_10,
	title        = {Understanding Android Obfuscation Techniques: A Large-Scale Investigation in the Wild},
	author       = {Dong, Shuaike and Li, Menghao and Diao, Wenrui and Liu, Xiangyu and Liu, Jian and Li, Zhou and Xu, Fenghao and Chen, Kai and Wang, XiaoFeng and Zhang, Kehuan},
	year         = 2018,
	booktitle    = {Security and Privacy in Communication Networks},
	publisher    = {Springer International Publishing},
	address      = {Cham},
	pages        = {172--192},
	isbn         = {978-3-030-01701-9},
	editor       = {Beyah, Raheem and Chang, Bing and Li, Yingjiu and Zhu, Sencun},
	abstract     = {Program code is a valuable asset to its owner. Due to the easy-to-reverse nature of Java, code protection for Android apps is of particular importance. To this end, code obfuscation is widely utilized by both legitimate app developers and malware authors, which complicates the representation of source code or machine code in order to hinder the manual investigation and code analysis. Despite many previous studies focusing on the obfuscation techniques, however, our knowledge of how obfuscation is applied by real-world developers is still limited.}
}
@inproceedings{10.1007/978-3-030-22038-9_14,
	title        = {TypeMiner: Recovering Types in Binary Programs Using Machine Learning},
	author       = {Maier, Alwin and Gascon, Hugo and Wressnegger, Christian and Rieck, Konrad},
	year         = 2019,
	booktitle    = {Detection of Intrusions and Malware, and Vulnerability Assessment},
	publisher    = {Springer International Publishing},
	address      = {Cham},
	pages        = {288--308},
	isbn         = {978-3-030-22038-9},
	editor       = {Perdisci, Roberto and Maurice, Cl{\'e}mentine and Giacinto, Giorgio and Almgren, Magnus},
	abstract     = {Closed-source software is a major hurdle for assessing the security of computer systems. In absence of source code, it is particularly difficult to locate vulnerabilities and malicious functionality, as crucial information is removed by the compilation process. Most notably, binary programs usually lack type information, which complicates spotting vulnerabilities such as integer flaws or type confusions dramatically. Moreover, data types are often essential for gaining a deeper understanding of the program logic. In this paper we present TypeMiner, a static method for recovering types in binary programs. We build on the assumption that types leave characteristic traits in compiled code that can be automatically identified using machine learning starting at usage locations determined by an analyst. We evaluate the performance of our method with 14 real world software projects written in C and show that it is able to correctly recover the data types in 76{\%}--93{\%} of the cases.}
}
@inproceedings{10.1007/978-3-030-49785-9_11,
	title        = {Evasion Is Not Enough: A Case Study of Android Malware},
	author       = {Berger, Harel and Hajaj, Chen and Dvir, Amit},
	year         = 2020,
	booktitle    = {Cyber Security Cryptography and Machine Learning},
	publisher    = {Springer International Publishing},
	address      = {Cham},
	pages        = {167--174},
	isbn         = {978-3-030-49785-9},
	editor       = {Dolev, Shlomi and Kolesnikov, Vladimir and Lodha, Sachin and Weiss, Gera},
	abstract     = {A growing number of Android malware detection systems are based on Machine Learning (ML) methods. However, ML methods are often vulnerable to evasion attacks, in which an adversary manipulates malicious instances so they are classified as benign. Here, we present a novel evaluation scheme for evasion attack generation that exploits the weak spots of known Android malware detection systems. We implement an innovative evasion attack on Drebin [3]. After our novel evasion attack, Drebin's detection rate decreased by 12{\%}. However, when inspecting the functionality and maliciousness of the manipulated instances, the maliciousness rate increased, whereas the functionality rate decreased by 72{\%}. We show that non-functional apps, do not constitute a threat to users and are thus useless from an attacker's point of view. Hence, future evaluations of attacks against Android malware detection systems should also address functionality and maliciousness tests.}
}
@inproceedings{10.1007/978-3-030-87839-9_4,
	title        = {DexRay: A Simple, yet Effective Deep Learning Approach to Android Malware Detection Based on Image Representation of Bytecode},
	author       = {Daoudi, Nadia and Samhi, Jordan and Kabore, Abdoul Kader and Allix, Kevin and Bissyand{\'e}, Tegawend{\'e} F. and Klein, Jacques},
	year         = 2021,
	booktitle    = {Deployable Machine Learning for Security Defense},
	publisher    = {Springer International Publishing},
	address      = {Cham},
	pages        = {81--106},
	isbn         = {978-3-030-87839-9},
	editor       = {Wang, Gang and Ciptadi, Arridhana and Ahmadzadeh, Ali},
	abstract     = {Computer vision has witnessed several advances in recent years, with unprecedented performance provided by deep representation learning research. Image formats thus appear attractive to other fields such as malware detection, where deep learning on images alleviates the need for comprehensively hand-crafted features generalising to different malware variants. We postulate that this research direction could become the next frontier in Android malware detection, and therefore requires a clear roadmap to ensure that new approaches indeed bring novel contributions. We contribute with a first building block by developing and assessing a baseline pipeline for image-based malware detection with straightforward steps.}
}
@inproceedings{10.1007/978-3-319-18467-8_34,
	title        = {ApkCombiner: Combining Multiple Android Apps to Support Inter-App Analysis},
	author       = {Li, Li and Bartel, Alexandre and Bissyand{\'e}, Tegawend{\'e} F. and Klein, Jacques and Traon, Yves Le},
	year         = 2015,
	booktitle    = {ICT Systems Security and Privacy Protection},
	publisher    = {Springer International Publishing},
	address      = {Cham},
	pages        = {513--527},
	isbn         = {978-3-319-18467-8},
	editor       = {Federrath, Hannes and Gollmann, Dieter},
	abstract     = {Android apps are made of components which can leak information between one another using the ICC mechanism. With the growing momentum of Android, a number of research contributions have led to tools for the intra-app analysis of Android apps. Unfortunately, these state-of-the-art approaches, and the associated tools, have long left out the security flaws that arise across the boundaries of single apps, in the interaction between several apps. In this paper, we present a tool called ApkCombiner which aims at reducing an inter-app communication problem to an intra-app inter-component communication problem. In practice, ApkCombiner combines different apps into a single apk on which existing tools can indirectly perform inter-app analysis. We have evaluated ApkCombiner on a dataset of 3,000 real-world Android apps, to demonstrate its capability to support static context-aware inter-app analysis scenarios.}
}
@inproceedings{10.1007/978-3-319-24018-3_12,
	title        = {How Current Android Malware Seeks to Evade Automated Code Analysis},
	author       = {Rasthofer, Siegfried and Asrar, Irfan and Huber, Stephan and Bodden, Eric},
	year         = 2015,
	booktitle    = {Information Security Theory and Practice},
	publisher    = {Springer International Publishing},
	address      = {Cham},
	pages        = {187--202},
	isbn         = {978-3-319-24018-3},
	editor       = {Akram, Raja Naeem and Jajodia, Sushil},
	abstract     = {First we report on a new threat campaign, underway in Korea, which infected around 20,000 Android users within two months. The campaign attacked mobile users with malicious applications spread via different channels, such as email attachments or SMS spam. A detailed investigation of the Android malware resulted in the identification of a new Android malware family Android/BadAccents. The family represents current state-of-the-art in mobile malware development for banking trojans.}
}
@inproceedings{10.1007/978-3-319-24177-7_15,
	title        = {DexHunter: Toward Extracting Hidden Code from Packed Android Applications},
	author       = {Zhang, Yueqian and Luo, Xiapu and Yin, Haoyang},
	year         = 2015,
	booktitle    = {Computer Security -- ESORICS 2015},
	publisher    = {Springer International Publishing},
	address      = {Cham},
	pages        = {293--311},
	isbn         = {978-3-319-24177-7},
	editor       = {Pernul, G{\"u}nther and Y A Ryan, Peter and Weippl, Edgar},
	abstract     = {The rapid growth of mobile application (or simply app) economy provides lucrative and profitable targets for hackers. Among OWASP's top ten mobile risks for 2014, the lack of binary protections makes it easy to reverse, modify, and repackage Android apps. Recently, a number of packing services have been proposed to protect Android apps by hiding the original executable file (i.e., dex file). However, little is known about their effectiveness and efficiency. In this paper, we perform the first systematic investigation on such services by answering two questions: (1) what are the major techniques used by these services and their effects on apps? (2) can the original dex file in a packed app be recovered? If yes, how? We not only reveal their techniques and evaluate their effects, but also propose and develop a novel system, named DexHunter, to extract dex files protected by these services. It is worth noting that DexHunter supports both the Dalvik virtual machine (DVM) and the new Android Runtime (ART). The experimental results show that DexHunter can extract dex files from packed apps effectively and efficiently.}
}
@inproceedings{10.1007/978-3-319-47560-8_9,
	title        = {Evaluation of Resource-Based App Repackaging Detection in Android},
	author       = {Gadyatskaya, Olga and Lezza, Andra-Lidia and Zhauniarovich, Yury},
	year         = 2016,
	booktitle    = {Secure IT Systems},
	publisher    = {Springer International Publishing},
	address      = {Cham},
	pages        = {135--151},
	isbn         = {978-3-319-47560-8},
	editor       = {Brumley, Billy Bob and R{\"o}ning, Juha},
	abstract     = {Android app repackaging threatens the health of application markets, as repackaged apps, besides stealing revenue for honest developers, are also a source of malware distribution. Techniques that rely on visual similarity of Android apps recently emerged as a way to tackle the repackaging detection problem, as code-based detection techniques often fail in terms of efficiency, and effectiveness when obfuscation is applied [19, 21]. Among such techniques, the resource-based repackaging detection approach that compares sets of files included in apks has arguably the best performance [10, 17, 20]. Yet, this approach has not been previously validated on a dataset of repackaged apps.}
}
@inproceedings{10.1007/978-3-319-56991-8_51,
	title        = {HADM: Hybrid Analysis for Detection of Malware},
	author       = {Xu, Lifan and Zhang, Dongping and Jayasena, Nuwan and Cavazos, John},
	year         = 2018,
	booktitle    = {Proceedings of SAI Intelligent Systems Conference (IntelliSys) 2016},
	publisher    = {Springer International Publishing},
	address      = {Cham},
	pages        = {702--724},
	isbn         = {978-3-319-56991-8},
	editor       = {Bi, Yaxin and Kapoor, Supriya and Bhatia, Rahul},
	abstract     = {Android is the most popular mobile operating system with a market share of over 80{\%} [1]. Due to its popularity and also its open source nature, Android is now the platform most targeted by malware, creating an urgent need for effective defense mechanisms to protect Android-enabled devices.}
}
@inproceedings{10.1007/978-3-319-65548-2_14,
	title        = {Android Application Collusion Demystified},
	author       = {Abro, Fauzia Idrees and Rajarajan, Muttukrishnan and Chen, Thomas M. and Rahulamathavan, Yogachandran},
	year         = 2017,
	booktitle    = {Future Network Systems and Security},
	publisher    = {Springer International Publishing},
	address      = {Cham},
	pages        = {176--187},
	isbn         = {978-3-319-65548-2},
	editor       = {Doss, Robin and Piramuthu, Selwyn and Zhou, Wei},
	abstract     = {Application collusion is an emerging threat to Android based devices. In app collusion, two or more apps collude in some manner to perform a malicious action that they are unable to do independently. Detection of colluding apps is a challenging task. Existing commercial malware detection systems analyse each app separately, hence fail to detect any joint malicious action performed by multiple apps through collusion. In this paper, we discuss the current state of research on app collusion and open challenges to the detection of colluding apps. We compare existing approaches and present an integrated approach to effectively detect app collusion.}
}
@inproceedings{10.1007/978-3-319-73697-6_1,
	title        = {FindEvasion: An Effective Environment-Sensitive Malware Detection System for the Cloud},
	author       = {Jia, Xiaoqi and Zhou, Guangzhe and Huang, Qingjia and Zhang, Weijuan and Tian, Donghai},
	year         = 2018,
	booktitle    = {Digital Forensics and Cyber Crime},
	publisher    = {Springer International Publishing},
	address      = {Cham},
	pages        = {3--17},
	isbn         = {978-3-319-73697-6},
	editor       = {Matou{\v{s}}ek, Petr and Schmiedecker, Martin},
	abstract     = {In recent years, environment-sensitive malwares are growing rapidly and they pose significant threat to cloud platforms. They may maliciously occupy the computing resources and steal the tenants' private data. The environment-sensitive malware can identify the operating environment and perform corresponding malicious behaviors in different environments. This greatly increased the difficulty of detection. At present, the research on automatic detection of environment-sensitive malwares is still rare, but it has attracted more and more attention.}
}
@inproceedings{10.1007/978-3-319-98989-1_3,
	title        = {PIAnalyzer: A Precise Approach for PendingIntent Vulnerability Analysis},
	author       = {Gro{\ss}, Sascha and Tiwari, Abhishek and Hammer, Christian},
	year         = 2018,
	booktitle    = {Computer Security},
	publisher    = {Springer International Publishing},
	address      = {Cham},
	pages        = {41--59},
	isbn         = {978-3-319-98989-1},
	editor       = {Lopez, Javier and Zhou, Jianying and Soriano, Miguel},
	abstract     = {PendingIntents are a powerful and universal feature of Android for inter-component communication. A PendingIntent holds a base intent to be executed by another application with the creator's permissions and identity without the creator necessarily residing in memory. While PendingIntents are useful for many scenarios, e.g., for setting an alarm or getting notified at some point in the future, insecure usage of PendingIntents causes severe security threats in the form of denial-of-service, identity theft, and privilege escalation attacks. An attacker may gain up to SYSTEM privileges to perform the most sensitive operations, e.g., deleting user's data on the device. However, so far no tool can detect these PendingIntent vulnerabilities.}
}
@inproceedings{10.1007/978-3-642-15512-3_17,
	title        = {Hybrid Analysis and Control of Malware},
	author       = {Roundy, Kevin A. and Miller, Barton P.},
	year         = 2010,
	booktitle    = {Recent Advances in Intrusion Detection},
	publisher    = {Springer Berlin Heidelberg},
	address      = {Berlin, Heidelberg},
	pages        = {317--338},
	isbn         = {978-3-642-15512-3},
	editor       = {Jha, Somesh and Sommer, Robin and Kreibich, Christian},
	abstract     = {Malware attacks necessitate extensive forensic analysis efforts that are manual-labor intensive because of the analysis-resistance techniques that malware authors employ. The most prevalent of these techniques are code unpacking, code overwriting, and control transfer obfuscations. We simplify the analyst's task by analyzing the code prior to its execution and by providing the ability to selectively monitor its execution. We achieve pre-execution analysis by combining static and dynamic techniques to construct control- and data-flow analyses. These analyses form the interface by which the analyst instruments the code. This interface simplifies the instrumentation task, allowing us to reduce the number of instrumented program locations by a hundred-fold relative to existing instrumentation-based methods of identifying unpacked code. We implement our techniques in SD-Dyninst and apply them to a large corpus of malware, performing analysis tasks such as code coverage tests and call-stack traversals that are greatly simplified by hybrid analysis.}
}
@inproceedings{10.1007/978-3-642-23644-0_18,
	title        = {Detecting Environment-Sensitive Malware},
	author       = {Lindorfer, Martina and Kolbitsch, Clemens and Milani Comparetti, Paolo},
	year         = 2011,
	booktitle    = {Recent Advances in Intrusion Detection},
	publisher    = {Springer Berlin Heidelberg},
	address      = {Berlin, Heidelberg},
	pages        = {338--357},
	isbn         = {978-3-642-23644-0},
	editor       = {Sommer, Robin and Balzarotti, Davide and Maier, Gregor},
	abstract     = {The execution of malware in an instrumented sandbox is a widespread approach for the analysis of malicious code, largely because it sidesteps the difficulties involved in the static analysis of obfuscated code. As malware analysis sandboxes increase in popularity, they are faced with the problem of malicious code detecting the instrumented environment to evade analysis. In the absence of an ``undetectable'', fully transparent analysis sandbox, defense against sandbox evasion is mostly reactive: Sandbox developers and operators tweak their systems to thwart individual evasion techniques as they become aware of them, leading to a never-ending arms race.}
}
@inproceedings{10.1007/978-3-642-30921-2_17,
	title        = {AndroidLeaks: Automatically Detecting Potential Privacy Leaks in Android Applications on a Large Scale},
	author       = {Gibler, Clint and Crussell, Jonathan and Erickson, Jeremy and Chen, Hao},
	year         = 2012,
	booktitle    = {Trust and Trustworthy Computing},
	publisher    = {Springer Berlin Heidelberg},
	address      = {Berlin, Heidelberg},
	pages        = {291--307},
	isbn         = {978-3-642-30921-2},
	editor       = {Katzenbeisser, Stefan and Weippl, Edgar and Camp, L. Jean and Volkamer, Melanie and Reiter, Mike and Zhang, Xinwen},
	abstract     = {As mobile devices become more widespread and powerful, they store more sensitive data, which includes not only users' personal information but also the data collected via sensors throughout the day. When mobile applications have access to this growing amount of sensitive information, they may leak it carelessly or maliciously.}
}
@inproceedings{10.1007/978-3-642-36742-7_39,
	title        = {AppGuard -- Enforcing User Requirements on Android Apps},
	author       = {Backes, Michael and Gerling, Sebastian and Hammer, Christian and Maffei, Matteo and von Styp-Rekowsky, Philipp},
	year         = 2013,
	booktitle    = {Tools and Algorithms for the Construction and Analysis of Systems},
	publisher    = {Springer Berlin Heidelberg},
	address      = {Berlin, Heidelberg},
	pages        = {543--548},
	isbn         = {978-3-642-36742-7},
	editor       = {Piterman, Nir and Smolka, Scott A.},
	abstract     = {The success of Android phones makes them a prominent target for malicious software, in particular since the Android permission system turned out to be inadequate to protect the user against security and privacy threats. This work presents AppGuard, a powerful and flexible system for the enforcement of user-customizable security policies on untrusted Android applications. AppGuard does not require any changes to a smartphone's firmware or root access. Our system offers complete mediation of security-relevant methods based on callee-site inline reference monitoring. We demonstrate the general applicability of AppGuard by several case studies, e.g., removing permissions from overly curious apps as well as defending against several recent real-world attacks on Android phones. Our technique exhibits very little space and runtime overhead. AppGuard is publicly available, has been invited to the Samsung Apps market, and has had more than 500,000 downloads so far.}
}
@inproceedings{10.1007/978-3-642-40787-1_26,
	title        = {Instrumenting Android and Java Applications as Easy as abc},
	author       = {Arzt, Steven and Rasthofer, Siegfried and Bodden, Eric},
	year         = 2013,
	booktitle    = {Runtime Verification},
	publisher    = {Springer Berlin Heidelberg},
	address      = {Berlin, Heidelberg},
	pages        = {364--381},
	isbn         = {978-3-642-40787-1},
	editor       = {Legay, Axel and Bensalem, Saddek},
	abstract     = {Program instrumentation is a widely used mechanism in different software engineering areas. It can be used for creating profilers and debuggers, for detecting programming errors at runtime, or for securing programs through inline reference monitoring.}
}
@inproceedings{10.1007/978-3-642-40787-1_31,
	title        = {Dynamic Analysis and Debugging of Binary Code for Security Applications},
	author       = {Li, Lixin and Wang, Chao},
	year         = 2013,
	booktitle    = {Runtime Verification},
	publisher    = {Springer Berlin Heidelberg},
	address      = {Berlin, Heidelberg},
	pages        = {403--423},
	doi          = {10.1007/978-3-642-40787-1_31},
	isbn         = {978-3-642-40787-1},
	editor       = {Legay, Axel and Bensalem, Saddek},
	abstract     = {Dynamic analysis techniques have made a significant impact in security practice, e.g. by automating some of the most tedious processes in detecting vulnerabilities. However, a significant gap remains between existing software tools and what many security applications demand. In this paper, we present our work on developing a cross-platform interactive analysis tool, which leverages techniques such as symbolic execution and taint tracking to analyze binary code on a range of platforms. The tool builds upon IDA, a popular reverse engineering platform, and provides a unified analysis engine to handle various instruction sets and operating systems. We have evaluated the tool on a set of real-world applications and shown that it can help identify the root causes of security vulnerabilities quickly.}
}
@inproceedings{10.1007/978-3-642-54804-8_10,
	title        = {Type-Based Taint Analysis for Java Web Applications},
	author       = {Huang, Wei and Dong, Yao and Milanova, Ana},
	year         = 2014,
	booktitle    = {Proceedings of the 17th International Conference on Fundamental Approaches to Software Engineering - Volume 8411},
	publisher    = {Springer-Verlag},
	address      = {Berlin, Heidelberg},
	pages        = {140–154},
	doi          = {10.1007/978-3-642-54804-8_10},
	isbn         = 9783642548031,
	url          = {https://doi.org/10.1007/978-3-642-54804-8\%5F10},
	abstract     = {Static taint analysis detects information flow vulnerabilities. It has gained considerable importance in the last decade, with the majority of work focusing on dataflow and points-to-based approaches.In this paper, we advocate type-based taint analysis. We present SFlow, a context-sensitive type system for secure information flow, and SFlowInfer, a corresponding worst-case cubic inference analysis. Our approach effectively handles reflection, libraries and frameworks, features notoriously difficult for dataflow and points-to-based taint analysis.We implemented SFlow and SFlowInfer. Empirical results on 13 real-world Java web applications show that our approach is scalable and also precise, achieving false positive rate of 15%.},
	numpages     = 15
}
@article{10.1007/s10664-021-09943-x,
	title        = {A first look at Android applications in Google Play related to COVID-19},
	author       = {Samhi, Jordan and Allix, Kevin and Bissyand{\'e}, Tegawend{\'e} F. and Klein, Jacques},
	year         = 2021,
	month        = apr,
	day          = 21,
	journal      = {Empirical Software Engineering},
	volume       = 26,
	number       = 4,
	pages        = 57,
	doi          = {10.1007/s10664-021-09943-x},
	issn         = {1573-7616},
	url          = {https://doi.org/10.1007/s10664-021-09943-x},
	abstract     = {Due to the convenience of access-on-demand to information and business solutions, mobile apps have become an important asset in the digital world. In the context of the COVID-19 pandemic, app developers have joined the response effort in various ways by releasing apps that target different user bases (e.g., all citizens or journalists), offer different services (e.g., location tracking or diagnostic-aid), provide generic or specialized information, etc. While many apps have raised some concerns by spreading misinformation or even malware, the literature does not yet provide a clear landscape of the different apps that were developed. In this study, we focus on the Android ecosystem and investigate Covid-related Android apps. In a best-effort scenario, we attempt to systematically identify all relevant apps and study their characteristics with the objective to provide a first taxonomy of Covid-related apps, broadening the relevance beyond the implementation of contact tracing. Overall, our study yields a number of empirical insights that contribute to enlarge the knowledge on Covid-related apps: (1) Developer communities contributed rapidly to the COVID-19, with dedicated apps released as early as January 2020; (2) Covid-related apps deliver digital tools to users (e.g., health diaries), serve to broadcast information to users (e.g., spread statistics), and collect data from users (e.g., for tracing); (3) Covid-related apps are less complex than standard apps; (4) they generally do not seem to leak sensitive data; (5) in the majority of cases, Covid-related apps are released by entities with past experience on the market, mostly official government entities or public health organizations.}
}
@article{10.1007/s11042-014-1922-5,
	title        = {Dynamic binary analyzer for scanning vulnerabilities with taint analysis},
	author       = {Choi, Young-Hyun and Park, Min-Woo and Eom, Jung-Ho and Chung, Tai-Myoung},
	year         = 2015,
	month        = apr,
	day          = {01},
	journal      = {Multimedia Tools and Applications},
	volume       = 74,
	number       = 7,
	pages        = {2301--2320},
	doi          = {10.1007/s11042-014-1922-5},
	issn         = {1573-7721},
	url          = {https://doi.org/10.1007/s11042-014-1922-5},
	abstract     = {In this paper, we introduce an overview of a dynamic binary analyzer for scanning vulnerabilities by performing taint analysis. People have been using the traditional security programs of pattern matching technique such as anti-virus and anti-spyware to protect their computer from malicious code. These security programs, however, cannot completely scan malicious behaviors attacking through the unknown vulnerability and are hard to protect from the attacks using self-modifying code which changes its own codes during runtime. To prevent these security risks, we develop the dynamic binary analyzer that can find these unknown vulnerabilities and self-modifying code. We adopt taint analysis to find vulnerabilities that transpire during runtime. Also using taint analysis let us check what effects have been occurred to programs by the input data and how they do spread widely to across the resources in an operating system. Adopting the dynamic analysis that drives and analyzes the system only in virtual machine circumstance through the emulator can make us detect the falsification of program code in program operational process. So we describe the framework of our analyzer and then explain the execution process and output of each process by using three test case demonstrations. Furthermore, we introduce several test cases of the security vulnerability for the demonstration and explain the results of proposed analyzer on test cases. The dynamic binary analyzer for scanning vulnerabilities with taint analysis (1) can find out existed security vulnerabilities in binary file, (2) can monitor all the actions of the binary file that affects operating system and (3) can be an expandable tool through the additional security element and policy.}
}
@article{10.1007/s11416-006-0012-2,
	title        = {Dynamic Analysis of Malicious Code},
	author       = {Bayer, Ulrich and Moser, Andreas and Kruegel, Christopher and Kirda, Engin},
	year         = 2006,
	month        = aug,
	day          = {01},
	journal      = {Journal in Computer Virology},
	volume       = 2,
	number       = 1,
	pages        = {67--77},
	doi          = {10.1007/s11416-006-0012-2},
	issn         = {1772-9904},
	url          = {https://doi.org/10.1007/s11416-006-0012-2},
	abstract     = {Malware analysis is the process of determining the purpose and functionality of a given malware sample (such as a virus, worm, or Trojan horse). This process is a necessary step to be able to develop effective detection techniques for malicious code. In addition, it is an important prerequisite for the development of removal tools that can thoroughly delete malware from an infected machine. Traditionally, malware analysis has been a manual process that is tedious and time-intensive. Unfortunately, the number of samples that need to be analyzed by security vendors on a daily basis is constantly increasing. This clearly reveals the need for tools that automate and simplify parts of the analysis process. In this paper, we present TTAnalyze, a tool for dynamically analyzing the behavior of Windows executables. To this end, the binary is run in an emulated operating system environment and its (security-relevant) actions are monitored. In particular, we record the Windows native system calls and Windows API functions that the program invokes. One important feature of our system is that it does not modify the program that it executes (e.g., through API call hooking or breakpoints), making it more difficult to detect by malicious code. Also, our tool runs binaries in an unmodified Windows environment, which leads to excellent emulation accuracy. These factors make TTAnalyze an ideal tool for quickly understanding the behavior of an unknown malware.}
}
@article{10.1007/s11416-011-0151-y,
	title        = {Malware classification based on call graph clustering},
	author       = {Kinable, Joris and Kostakis, Orestis},
	year         = 2011,
	month        = nov,
	day          = {01},
	journal      = {Journal in Computer Virology},
	volume       = 7,
	number       = 4,
	pages        = {233--245},
	doi          = {10.1007/s11416-011-0151-y},
	issn         = {1772-9904},
	url          = {https://doi.org/10.1007/s11416-011-0151-y},
	abstract     = {Each day, anti-virus companies receive tens of thousands samples of potentially harmful executables. Many of the malicious samples are variations of previously encountered malware, created by their authors to evade pattern-based detection. Dealing with these large amounts of data requires robust, automatic detection approaches. This paper studies malware classification based on call graph clustering. By representing malware samples as call graphs, it is possible to abstract certain variations away, enabling the detection of structural similarities between samples. The ability to cluster similar samples together will make more generic detection techniques possible, thereby targeting the commonalities of the samples within a cluster. To compare call graphs mutually, we compute pairwise graph similarity scores via graph matchings which approximately minimize the graph edit distance. Next, to facilitate the discovery of similar malware samples, we employ several clustering algorithms, including k-medoids and Density-Based Spatial Clustering of Applications with Noise (DBSCAN). Clustering experiments are conducted on a collection of real malware samples, and the results are evaluated against manual classifications provided by human malware analysts. Experiments show that it is indeed possible to accurately detect malware families via call graph clustering. We anticipate that in the future, call graphs can be used to analyse the emergence of new malware families, and ultimately to automate implementation of generic detection schemes.}
}
@article{10.1007/s11416-014-0203-1,
	title        = {Statically detecting use after free on binary code},
	author       = {Feist, Josselin and Mounier, Laurent and Potet, Marie-Laure},
	year         = 2014,
	month        = aug,
	day          = {01},
	journal      = {Journal of Computer Virology and Hacking Techniques},
	volume       = 10,
	number       = 3,
	pages        = {211--217},
	doi          = {10.1007/s11416-014-0203-1},
	issn         = {2263-8733},
	url          = {https://doi.org/10.1007/s11416-014-0203-1},
	abstract     = {We present GUEB a static tool detecting Use after Free vulnerabilities on disassembled code. This tool has been evaluated on a real vulnerability in the ProFTPD application (CVE-2011-4130).}
}
@article{10.1007/s11416-015-0261-z,
	title        = {A comparison of static, dynamic, and hybrid analysis for malware detection},
	author       = {Damodaran, Anusha and Troia, Fabio Di and Visaggio, Corrado Aaron and Austin, Thomas H. and Stamp, Mark},
	year         = 2017,
	month        = feb,
	day          = {01},
	journal      = {Journal of Computer Virology and Hacking Techniques},
	volume       = 13,
	number       = 1,
	pages        = {1--12},
	doi          = {10.1007/s11416-015-0261-z},
	issn         = {2263-8733},
	url          = {https://doi.org/10.1007/s11416-015-0261-z},
	abstract     = {In this research, we compare malware detection techniques based on static, dynamic, and hybrid analysis. Specifically, we train Hidden Markov Models (HMMs) on both static and dynamic feature sets and compare the resulting detection rates over a substantial number of malware families. We also consider hybrid cases, where dynamic analysis is used in the training phase, with static techniques used in the detection phase, and vice versa. In our experiments, a fully dynamic approach generally yields the best detection rates. We discuss the implications of this research for malware detection based on hybrid techniques.}
}
@article{10.1016/j.cose.2016.01.008,
	title        = {Dexteroid: Detecting malicious behaviors in Android apps using reverse-engineered life cycle models},
	author       = {Junaid, Mohsin and Liu, Donggang and Kung, David},
	year         = 2016,
	month        = jun,
	journal      = {computers \& security},
	publisher    = {Elsevier Advanced Technology Publications},
	address      = {GBR},
	volume       = 59,
	number       = {C},
	pages        = {92–117},
	doi          = {10.1016/j.cose.2016.01.008},
	issn         = {0167-4048},
	url          = {https://doi.org/10.1016/j.cose.2016.01.008},
	issue_date   = {June 2016},
	abstract     = {The amount of Android malware has increased greatly during the last few years. Static analysis is widely used in detecting such malware by analyzing the code without execution. The effectiveness of current tools relies on the app model as well as the malware detection algorithm which analyzes the app model. If the model and/or the algorithm is inadequate, then sophisticated attacks that are triggered by specific sequences of events will not be detected.This paper presents a static analysis framework called Dexteroid, which uses reverse-engineered life cycle models to accurately capture the behaviors of Android components. Dexteroid systematically derives event sequences from the models, and uses them to detect attacks launched by specific ordering of events. A prototype implementation of Dexteroid detects two types of attacks: (1) leakage of private information, and (2) sending SMS to premium-rate numbers. A series of experiments are conducted on 1526 Google Play apps, 1259 Genome Malware apps, and a suite of benchmark apps called DroidBench and the results are compared with a state-of-the-art static analysis tool called FlowDroid. The evaluation results show that the proposed framework is effective and efficient in terms of precision, recall, and execution time.},
	numpages     = 26,
	keywords     = {Static analysis, Android, Malware, Privacy, Mobile app security, Life cycle models}
}
@article{chen2022automatically,
	title        = {Automatically Distilling Storyboard with Rich Features for Android Apps},
	author       = {Chen, Sen and Fan, Lingling and Chen, Chunyang and Liu, Yang},
	year         = 2022,
	journal      = {IEEE Transactions on Software Engineering},
	publisher    = {IEEE}
}
@article{10.1016/j.cose.2016.11.011,
	title        = {DroidNative: Automating and optimizing detection of Android native code malware variants},
	author       = {Shahid Alam and Zhengyang Qu and Ryan Riley and Yan Chen and Vaibhav Rastogi},
	year         = 2017,
	journal      = {Computers \& Security},
	volume       = 65,
	pages        = {230--246},
	doi          = {https://doi.org/10.1016/j.cose.2016.11.011},
	issn         = {0167-4048},
	url          = {http://www.sciencedirect.com/science/article/pii/S016740481630164X},
	keywords     = {Android native code, Malware analysis, Malware variant detection, Control flow analysis, Data mining},
	abstract     = {According to the Symantec and F-Secure threat reports, mobile malware development in 2013 and 2014 has continued to focus almost exclusively (~99\%) on the Android platform. Malware writers are applying stealthy mutations (obfuscations) to create malware variants, thwarting detection by signature-based detectors. In addition, the plethora of more sophisticated detectors making use of static analysis techniques to detect such variants operate only at the bytecode level, meaning that malware embedded in native code goes undetected. A recent study shows that 86\% of the most popular Android applications contain native code, making native code malware a plausible threat vector. This paper proposes DroidNative, an Android malware detector that uses specific control flow patterns to reduce the effect of obfuscations and provides automation. As far as we know, DroidNative is the first system that builds cross-platform (x86 and ARM) semantic-based signatures at the Android native code level, allowing the system to detect malware embedded in either bytecode or native code. When tested with a dataset of 5490 samples, DroidNative achieves a detection rate (DR) of 93.57\% and a false positive rate of 2.7\%. When tested with traditional malware variants, it achieves a DR of 99.48\%, compared to the DRs of academic and commercial tools that range from 8.33\% to 93.22\%.}
}
@article{10.1016/j.infsof.2017.04.001,
	title        = {Static analysis of android apps: A systematic literature review},
	author       = {Li Li and Tegawendé F. Bissyandé and Mike Papadakis and Siegfried Rasthofer and Alexandre Bartel and Damien Octeau and Jacques Klein and Le Traon},
	year         = 2017,
	journal      = {Information and Software Technology},
	volume       = 88,
	pages        = {67--95},
	doi          = {https://doi.org/10.1016/j.infsof.2017.04.001},
	issn         = {0950-5849},
	url          = {http://www.sciencedirect.com/science/article/pii/S0950584917302987},
	abstract     = {Context Static analysis exploits techniques that parse program source code or bytecode, often traversing program paths to check some program properties. Static analysis approaches have been proposed for different tasks, including for assessing the security of Android apps, detecting app clones, automating test cases generation, or for uncovering non-functional issues related to performance or energy. The literature thus has proposed a large body of works, each of which attempts to tackle one or more of the several challenges that program analyzers face when dealing with Android apps. Objective We aim to provide a clear view of the state-of-the-art works that statically analyze Android apps, from which we highlight the trends of static analysis approaches, pinpoint where the focus has been put, and enumerate the key aspects where future researches are still needed. Method We have performed a systematic literature review (SLR) which involves studying 124 research papers published in software engineering, programming languages and security venues in the last 5 years (January 2011–December 2015). This review is performed mainly in five dimensions: problems targeted by the approach, fundamental techniques used by authors, static analysis sensitivities considered, android characteristics taken into account and the scale of evaluation performed. Results Our in-depth examination has led to several key findings: 1) Static analysis is largely performed to uncover security and privacy issues; 2) The Soot framework and the Jimple intermediate representation are the most adopted basic support tool and format, respectively; 3) Taint analysis remains the most applied technique in research approaches; 4) Most approaches support several analysis sensitivities, but very few approaches consider path-sensitivity; 5) There is no single work that has been proposed to tackle all challenges of static analysis that are related to Android programming; and 6) Only a small portion of state-of-the-art works have made their artifacts publicly available. Conclusion The research community is still facing a number of challenges for building approaches that are aware altogether of implicit-Flows, dynamic code loading features, reflective calls, native code and multi-threading, in order to implement sound and highly precise static analyzers.}
}
@article{10.1016/S0164-12120200066-3,
	title        = {Advanced obfuscation techniques for Java bytecode},
	author       = {Jien-Tsai Chan and Wuu Yang},
	year         = 2004,
	journal      = {Journal of Systems and Software},
	volume       = 71,
	number       = 1,
	pages        = {1--10},
	doi          = {https://doi.org/10.1016/S0164-1212(02)00066-3},
	issn         = {0164-1212},
	url          = {https://www.sciencedirect.com/science/article/pii/S0164121202000663},
	keywords     = {Program protection, Bytecode obfuscation, Java programming language},
	abstract     = {There exist several obfuscation tools for preventing Java bytecode from being decompiled. Most of these tools simply scramble the names of the identifiers stored in a bytecode by substituting the identifiers with meaningless names. However, the scrambling technique cannot deter a determined cracker very long. We propose several advanced obfuscation techniques that make Java bytecode impossible to recompile or make the decompiled program difficult to understand and to recompile. The crux of our approach is to over use an identifier. That is, an identifier can denote several entities, such as types, fields, and methods, simultaneously. An additional benefit is that the size of the bytecode is reduced because fewer and shorter identifier names are used. Furthermore, we also propose several techniques to intentionally introduce syntactic and semantic errors into the decompiled program while preserving the original behaviors of the bytecode. Thus, the decompiled program would have to be debugged manually. Although our basic approach is to scramble the identifiers in Java bytecode, the scrambled bytecode produced with our techniques is much harder to crack than that produced with other identifier scrambling techniques. Furthermore, the run-time efficiency of the obfuscated bytecode is also improved because the size of the bytecode becomes smaller after obfuscation.}
}
@article{10.1090/S0002-9947-1953-0053041-6,
	title        = {Classes of Recursively Enumerable Sets and Their Decision Problems},
	author       = {H. G. Rice},
	year         = 1953,
	journal      = {Transactions of the American Mathematical Society},
	publisher    = {American Mathematical Society},
	volume       = 74,
	number       = 2,
	pages        = {358--366},
	doi          = {10.1090/S0002-9947-1953-0053041-6},
	issn         = {00029947},
	url          = {http://www.jstor.org/stable/1990888}
}
@article{10.1109/72.788640,
	title        = {An overview of statistical learning theory},
	author       = {V. N. {Vapnik}},
	year         = 1999,
	journal      = {IEEE Transactions on Neural Networks},
	volume       = 10,
	number       = 5,
	pages        = {988--999},
	doi          = {10.1109/72.788640}
}
@inproceedings{10.1109/ASE.2015.69,
	title        = {Static Analysis of Implicit Control Flow: Resolving Java Reflection and Android Intents},
	author       = {Barros, Paulo and Just, Ren\'{e} and Millstein, Suzanne and Vines, Paul and Dietl, Werner and d'Amorim, Marcelo and Ernst, Michael D.},
	year         = 2015,
	booktitle    = {Proceedings of the 30th IEEE/ACM International Conference on Automated Software Engineering},
	location     = {Lincoln, Nebraska},
	publisher    = {IEEE Press},
	series       = {ASE '15},
	pages        = {669–679},
	doi          = {10.1109/ASE.2015.69},
	isbn         = 9781509000241,
	url          = {https://doi.org/10.1109/ASE.2015.69},
	abstract     = {Implicit or indirect control flow is a transfer of control between procedures using some mechanism other than an explicit procedure call. Implicit control flow is a staple design pattern that adds flexibility to system design. However, it is challenging for a static analysis to compute or verify properties about a system that uses implicit control flow.This paper presents static analyses for two types of implicit control flow that frequently appear in Android apps: Java reflection and Android intents. Our analyses help to resolve where control flows and what data is passed. This information improves the precision of downstream analyses, which no longer need to make conservative assumptions about implicit control flow.We have implemented our techniques for Java. We enhanced an existing security analysis with a more precise treatment of reflection and intents. In a case study involving ten real-world Android apps that use both intents and reflection, the precision of the security analysis was increased on average by two orders of magnitude. The precision of two other downstream analyses was also improved.},
	numpages     = 11
}
@inproceedings{10.1109/ASE.2019.00020,
	title        = {A Qualitative Analysis of Android Taint-Analysis Results},
	author       = {Luo, Linghui and Bodden, Eric and Sp\"{a}th, Johannes},
	year         = 2019,
	booktitle    = {Proceedings of the 34th IEEE/ACM International Conference on Automated Software Engineering},
	location     = {San Diego, California},
	publisher    = {IEEE Press},
	series       = {ASE '19},
	pages        = {102–114},
	doi          = {10.1109/ASE.2019.00020},
	isbn         = 9781728125084,
	url          = {https://doi.org/10.1109/ASE.2019.00020},
	abstract     = {In the past, researchers have developed a number of popular taint-analysis approaches, particularly in the context of Android applications. Numerous studies have shown that automated code analyses are adopted by developers only if they yield a good "signal to noise ratio", i.e., high precision. Many previous studies have reported analysis precision quantitatively, but this gives little insight into what can and should be done to increase precision further.To guide future research on increasing precision, we present a comprehensive study that evaluates static Android taint-analysis results on a qualitative level. To unravel the exact nature of taint flows, we have designed COVA, an analysis tool to compute partial path constraints that inform about the circumstances under which taint flows may actually occur in practice.We have conducted a qualitative study on the taint flows reported by FlowDroid in 1,022 real-world Android applications. Our results reveal several key findings: Many taint flows occur only under specific conditions, e.g., environment settings, user interaction, I/O. Taint analyses should consider the application context to discern such situations. COVA shows that few taint flows are guarded by multiple different kinds of conditions simultaneously, so tools that seek to confirm true positives dynamically can concentrate on one kind at a time, e.g., only simulating user interactions. Lastly, many false positives arise due to a too liberal source/sink configuration. Taint analyses must be more carefully configured, and their configuration could benefit from better tool assistance.},
	numpages     = 13,
	keywords     = {path conditions, taint analysis, android}
}
@inproceedings{10.1109/AsiaJCIS.2012.18,
	title        = {DroidMat: Android Malware Detection through Manifest and API Calls Tracing},
	author       = {D. Wu and C. Mao and T. Wei and H. Lee and K. Wu},
	year         = 2012,
	month        = aug,
	booktitle    = {2012 Seventh Asia Joint Conference on Information Security (ASIA JCIS)},
	publisher    = {IEEE Computer Society},
	address      = {Los Alamitos, CA, USA},
	pages        = {62--69},
	doi          = {10.1109/AsiaJCIS.2012.18},
	url          = {https://doi.ieeecomputersociety.org/10.1109/AsiaJCIS.2012.18},
	keywords     = {malware;androids;humanoid robots;smart phones;feature extraction;clustering algorithms}
}
@inproceedings{10.1109/BADGERS.2014.7,
	title        = {ANDRUBIS -- 1,000,000 Apps Later: A View on Current Android Malware Behaviors},
	author       = {Lindorfer, Martina and Neugschwandtner, Matthias and Weichselbaum, Lukas and Fratantonio, Yanick and Veen, Victor van der and Platzer, Christian},
	year         = 2014,
	booktitle    = {2014 Third International Workshop on Building Analysis Datasets and Gathering Experience Returns for Security (BADGERS)},
	pages        = {3--17},
	doi          = {10.1109/BADGERS.2014.7}
}
@phdthesis{andersen1994program,
	title        = {Program analysis and specialization for the {C} programming language},
	author       = {Andersen, Lars Ole},
	year         = 1994,
	school       = {Cornell}
}
@inproceedings{10.1145/237721.237727,
	title        = {Points-to Analysis in Almost Linear Time},
	author       = {Steensgaard, Bjarne},
	year         = 1996,
	booktitle    = {Proceedings of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
	location     = {St. Petersburg Beach, Florida, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {POPL '96},
	pages        = {32–41},
	doi          = {10.1145/237721.237727},
	isbn         = {0897917693},
	url          = {https://doi.org/10.1145/237721.237727},
	abstract     = {We present an interprocedural flow-insensitive points-to analysis based on type inference methods with an almost linear time cost complexity To our knowledge, this is the asymptotically fastest non-trivial interprocedural points-to analysis algorithm yet described The algorithm is based on a non-standard type system. The type inferred for any variable represents a set of locations and includes a type which in turn represents a set of locations possibly pointed to by the variable. The type inferred for a function variable represents a set of functions It may point to and includes a type signature for these functions The results are equivalent to those of a flow-insensitive alias analysis (and control flow analysis) that assumes alias relations are reflexive and transitive.This work makes three contributions. The first is a type system for describing a universally valid storage shape graph for a program in linear space. The second is a constraint system which often leads to better results than the "obvious" constraint system for the given type system The third is an almost linear time algorithm for points-to analysis by solving a constraint system.},
	numpages     = 10
}
@inproceedings{10.1109/DSN.2008.4630086,
	title        = {Towards an understanding of anti-virtualization and anti-debugging behavior in modern malware},
	author       = {Xu Chen and J. Andersen and Z. Mao and M. Bailey and J. Nazario},
	year         = 2008,
	month        = jun,
	booktitle    = {2008 IEEE International Conference on Dependable Systems \& Networks With FTCS and DCC (DSN)},
	publisher    = {IEEE Computer Society},
	address      = {Los Alamitos, CA, USA},
	doi          = {10.1109/DSN.2008.4630086},
	issn         = {1530-0889},
	url          = {https://doi.ieeecomputersociety.org/10.1109/DSN.2008.4630086}
}
@inproceedings{10.1109/DSN.2014.30,
	title        = {On Tracking Information Flows through JNI in Android Applications},
	author       = {C. Qian and X. Luo and Y. Shao and A. S. Chan},
	year         = 2014,
	month        = jun,
	booktitle    = {2014 44th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)},
	publisher    = {IEEE Computer Society},
	address      = {Los Alamitos, CA, USA},
	pages        = {180--191},
	doi          = {10.1109/DSN.2014.30},
	url          = {https://doi.ieeecomputersociety.org/10.1109/DSN.2014.30},
	keywords     = {java;libraries;context;androids;humanoid robots;engines;games}
}
@inproceedings{10.1109/DSN.2016.56,
	title        = {Repackage-Proofing Android Apps},
	author       = {Luo, Lannan and Fu, Yu and Wu, Dinghao and Zhu, Sencun and Liu, Peng},
	year         = 2016,
	booktitle    = {2016 46th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)},
	pages        = {550--561},
	doi          = {10.1109/DSN.2016.56}
}
@inproceedings{10.1109/EISIC.2012.34,
	title        = {A Machine Learning Approach to Android Malware Detection},
	author       = {J. {Sahs} and L. {Khan}},
	year         = 2012,
	booktitle    = {2012 European Intelligence and Security Informatics Conference},
	pages        = {141--147},
	doi          = {10.1109/EISIC.2012.34}
}
@inproceedings{10.1109/HPCC-CSS-ICESS.2015.39,
	title        = {Automated Detection and Analysis for Android Ransomware},
	author       = {Yang, Tianda and Yang, Yu and Qian, Kai and Lo, Dan Chia-Tien and Qian, Ying and Tao, Lixin},
	year         = 2015,
	booktitle    = {2015 IEEE 17th International Conference on High Performance Computing and Communications, 2015 IEEE 7th International Symposium on Cyberspace Safety and Security, and 2015 IEEE 12th International Conference on Embedded Software and Systems},
	pages        = {1338--1343},
	doi          = {10.1109/HPCC-CSS-ICESS.2015.39}
}
@inproceedings{10.1109/ICCCI.2018.8441295,
	title        = {HAAMD: Hybrid Analysis for Android Malware Detection},
	author       = {Choudhary, Mahima and Kishore, Brij},
	year         = 2018,
	booktitle    = {2018 International Conference on Computer Communication and Informatics (ICCCI)},
	pages        = {1--4},
	doi          = {10.1109/ICCCI.2018.8441295}
}
@inproceedings{10.1109/ICIP.2001.958946,
	title        = {One-class SVM for learning in image retrieval},
	author       = {{Yunqiang Chen} and {Xiang Sean Zhou} and T. S. {Huang}},
	year         = 2001,
	booktitle    = {Proceedings 2001 International Conference on Image Processing (Cat. No.01CH37205)},
	volume       = 1,
	pages        = {34--37 vol.1},
	doi          = {10.1109/ICIP.2001.958946}
}
@inproceedings{10.1109/ICSE43902.2021.00126,
	title        = {RAICC: Revealing Atypical Inter-Component Communication in Android Apps},
	author       = {J. Samhi and A. Bartel and T. F. Bissyande and J. Klein},
	year         = 2021,
	month        = may,
	booktitle    = {2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)},
	publisher    = {IEEE Computer Society},
	address      = {Los Alamitos, CA, USA},
	pages        = {1398--1409},
	doi          = {10.1109/ICSE43902.2021.00126},
	isbn         = 9781450390859,
	url          = {https://doi.org/10.1109/ICSE43902.2021.00126},
	numpages     = 12,
	keywords     = {analytical models;tools;security;leak detection;task analysis;standards;software engineering}
}
@inproceedings{10.1109/ICSESS.2017.8342924,
	title        = {Detecting environment-sensitive malware based on taint analysis},
	author       = {Shi, Dawei and Tang, Xiucun and Ye, Zhibin},
	year         = 2017,
	booktitle    = {2017 8th IEEE International Conference on Software Engineering and Service Science (ICSESS)},
	pages        = {322--327},
	doi          = {10.1109/ICSESS.2017.8342924}
}
@inproceedings{10.1109/ICSM.1997.624245,
	title        = {Intraprocedural Static Slicing of Binary Executables},
	author       = {A. Fraboulet and C. Cifuentes},
	year         = 1997,
	month        = oct,
	booktitle    = {2013 IEEE International Conference on Software Maintenance},
	publisher    = {IEEE Computer Society},
	address      = {Los Alamitos, CA, USA},
	pages        = 188,
	doi          = {10.1109/ICSM.1997.624245},
	issn         = {1063-6773},
	url          = {https://doi.ieeecomputersociety.org/10.1109/ICSM.1997.624245},
	keywords     = {static slicing;disassembly;binary code;goto jumps;reverse engineering}
}
@inproceedings{10.1109/ICSME.2017.59,
	title        = {Semantics-Aware Machine Learning for Function Recognition in Binary Code},
	author       = {Wang, Shuai and Wang, Pei and Wu, Dinghao},
	year         = 2017,
	booktitle    = {2017 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
	pages        = {388--398},
	doi          = {10.1109/ICSME.2017.59}
}
@inproceedings{10.1109/ICSME.2018.00019,
	title        = {BinMatch: A Semantics-Based Hybrid Approach on Binary Code Clone Analysis},
	author       = {Y. {Hu} and Y. {Zhang} and J. {Li} and H. {Wang} and B. {Li} and D. {Gu}},
	year         = 2018,
	booktitle    = {2018 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
	pages        = {104--114},
	doi          = {10.1109/ICSME.2018.00019}
}
@inproceedings{10.1109/ICSME.2019.00013,
	title        = {Do Energy-Oriented Changes Hinder Maintainability?},
	author       = {Cruz, Luis and Abreu, Rui and Grundy, John and Li, Li and Xia, Xin},
	year         = 2019,
	booktitle    = {2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
	pages        = {29--40},
	doi          = {10.1109/ICSME.2019.00013}
}
@inproceedings{10.1109/ICTAI.2013.53,
	title        = {Machine Learning for Android Malware Detection Using Permission and API Calls},
	author       = {N. {Peiravian} and X. {Zhu}},
	year         = 2013,
	booktitle    = {2013 IEEE 25th International Conference on Tools with Artificial Intelligence},
	pages        = {300--305},
	doi          = {10.1109/ICTAI.2013.53}
}
@inproceedings{10.1109/InfoSec.2015.7435516,
	title        = {Android spyware disease and medication},
	author       = {Saad, Mustafa Hassan and Serageldin, Ahmed and Salama, Goda Ismaeel},
	year         = 2015,
	booktitle    = {2015 Second International Conference on Information Security and Cyber Forensics (InfoSec)},
	pages        = {118--125},
	doi          = {10.1109/InfoSec.2015.7435516}
}
@inproceedings{10.1109/ISSA.2012.6320432,
	title        = {Android botnets on the rise: Trends and characteristics},
	author       = {Pieterse, Heloise and Olivier, Martin S},
	year         = 2012,
	booktitle    = {2012 Information Security for South Africa},
	pages        = {1--5},
	doi          = {10.1109/ISSA.2012.6320432}
}
@inproceedings{10.1109/ISSRE5003.2020.00032,
	title        = {An Empirical Evaluation of GDPR Compliance Violations in Android mHealth Apps},
	author       = {Fan, Ming and Yu, Le and Chen, Sen and Zhou, Hao and Luo, Xiapu and Li, Shuyue and Liu, Yang and Liu, Jun and Liu, Ting},
	year         = 2020,
	booktitle    = {ISSRE},
	pages        = {253--264},
	doi          = {10.1109/ISSRE5003.2020.00032}
}
@inproceedings{10.1109/IWCMC.2014.6906344,
	title        = {DroidTrace: A ptrace based Android dynamic analysis system with forward execution capability},
	author       = {M. {Zheng} and M. {Sun} and J. C. S. {Lui}},
	year         = 2014,
	booktitle    = {2014 International Wireless Communications and Mobile Computing Conference (IWCMC)},
	pages        = {128--133},
	doi          = {10.1109/IWCMC.2014.6906344}
}
@inproceedings{10.1109/MobileSoft.2015.24,
	title        = {Modeling and Test Case Generation of Inter-component Communication in Android},
	author       = {A. Jha and S. Lee and W. Lee},
	year         = 2015,
	month        = may,
	booktitle    = {2015 2nd ACM International Conference on Mobile Software Engineering and Systems (MOBILESoft)},
	publisher    = {IEEE Computer Society},
	address      = {Los Alamitos, CA, USA},
	pages        = {113--116},
	doi          = {10.1109/MobileSoft.2015.24},
	url          = {https://doi.ieeecomputersociety.org/10.1109/MobileSoft.2015.24},
	keywords     = {androids;humanoid robots;unified modeling language;security;testing;mobile communication;software engineering}
}
@article{10.1109/MSP.2009.26,
	title        = {Understanding Android Security},
	author       = {Enck, William and Ongtang, Machigar and McDaniel, Patrick},
	year         = 2009,
	month        = jan,
	journal      = {IEEE Security and Privacy},
	publisher    = {IEEE Educational Activities Department},
	address      = {USA},
	volume       = 7,
	number       = 1,
	pages        = {50–57},
	doi          = {10.1109/MSP.2009.26},
	issn         = {1540-7993},
	url          = {https://doi.org/10.1109/MSP.2009.26},
	issue_date   = {January 2009},
	abstract     = {Google's Android platform is a widely anticipated open source operating system for mobile phones. This article describes Android's security model and attempts to unmask the complexity of secure application development. The authors conclude by identifying lessons and opportunities for future enhancements.},
	numpages     = 8,
	keywords     = {Smartphones, mobile phones, security, Android}
}
@inproceedings{10.1109/MSR52588.2021.00069,
	title        = {AndroidCompass: A Dataset of Android Compatibility Checks in Code Repositories},
	author       = {Sebastian Nielebock and Paul Blockhaus and Jacob Kr\"{u}ger and Frank Ortmeier},
	year         = 2021,
	booktitle    = {Proceedings of the 2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR) - Data Showcase Track},
	doi          = {10.1109/MSR52588.2021.00069},
	isbn         = {978-1-7281-8710-5},
	url          = {https://arxiv.org/abs/2103.09620 https://doi.org/10.5281/zenodo.4428340 https://www.youtube.com/watch?v=M3ruWediurs},
	editor       = {IEEE},
	date         = {2021-05-17},
	keywords     = {Android, API, API Misuse, API Misuse Detection, compatibility, Dataset, Misuse},
	pubstate     = {published},
	tppubtype    = {inproceedings}
}
@inproceedings{10.1109/MSR52588.2021.00076,
	title        = {AndroCT: Ten Years of App Call Traces in Android},
	author       = {Li, Wen and Fu, Xiaoqin and Cai, Haipeng},
	year         = 2021,
	booktitle    = {2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR)},
	pages        = {570--574},
	doi          = {10.1109/MSR52588.2021.00076}
}
@inproceedings{10.1109/MSR52588.2021.00082,
	title        = {Andror2: A Dataset of Manually-Reproduced Bug Reports for Android apps},
	author       = {Wendland, Tyler and Sun, Jingyang and Mahmud, Junayed and Mansur, S. M. Hasan and Huang, Steven and Moran, Kevin and Rubin, Julia and Fazzini, Mattia},
	year         = 2021,
	booktitle    = {2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR)},
	pages        = {600--604},
	doi          = {10.1109/MSR52588.2021.00082}
}
@inproceedings{10.1109/NTMS.2016.7792435,
	title        = {ANASTASIA: ANdroid mAlware detection using STatic analySIs of Applications},
	author       = {H. {Fereidooni} and M. {Conti} and D. {Yao} and A. {Sperduti}},
	year         = 2016,
	booktitle    = {2016 8th IFIP International Conference on New Technologies, Mobility and Security (NTMS)},
	pages        = {1--5},
	doi          = {10.1109/NTMS.2016.7792435}
}
@inproceedings{10.1109/QRS.2015.36,
	title        = {Potential Component Leaks in Android Apps: An Investigation into a New Feature Set for Malware Detection},
	author       = {Li, Li and Allix, Kevin and Li, Daoyuan and Bartel, Alexandre and Bissyandé, Tegawendé F. and Klein, Jacques},
	year         = 2015,
	booktitle    = {2015 IEEE International Conference on Software Quality, Reliability and Security},
	pages        = {195--200},
	doi          = {10.1109/QRS.2015.36}
}
@inproceedings{10.1109/SANER.2016.52,
	title        = {An Investigation into the Use of Common Libraries in Android Apps},
	author       = {Li, Li and Bissyandé, Tegawendé F. and Klein, Jacques and Le Traon, Yves},
	year         = 2016,
	booktitle    = {2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)},
	volume       = 1,
	pages        = {403--414},
	doi          = {10.1109/SANER.2016.52}
}
@inproceedings{10.1109/SP.2012.16,
	title        = {Dissecting Android Malware: Characterization and Evolution},
	author       = {Xuxian Jiang and Yajin Zhou},
	year         = 2012,
	month        = may,
	booktitle    = {2012 IEEE Symposium on Security and Privacy},
	publisher    = {IEEE Computer Society},
	address      = {Los Alamitos, CA, USA},
	pages        = {95--109},
	doi          = {10.1109/SP.2012.16},
	issn         = {1081-6011},
	url          = {https://doi.ieeecomputersociety.org/10.1109/SP.2012.16},
	keywords     = {malware;smart phones;androids;humanoid robots;payloads;mobile communication;smartphone security;android malware}
}
@inproceedings{10.1109/SP.2016.17,
	title        = {SOK: (State of) The Art of War: Offensive Techniques in Binary Analysis},
	author       = {Y. Shoshitaishvili and R. Wang and C. Salls and N. Stephens and M. Polino and A. Dutcher and J. Grosen and S. Feng and C. Hauser and C. Kruegel and G. Vigna},
	year         = 2016,
	month        = may,
	booktitle    = {2016 IEEE Symposium on Security and Privacy (SP)},
	publisher    = {IEEE Computer Society},
	address      = {Los Alamitos, CA, USA},
	pages        = {138--157},
	doi          = {10.1109/SP.2016.17},
	issn         = {2375-1207},
	url          = {https://doi.ieeecomputersociety.org/10.1109/SP.2016.17},
	keywords     = {computer bugs;semantics;security;binary codes;engines;operating systems}
}
@inproceedings{10.1109/SP.2016.29,
	title        = {Following Devil's Footprints: Cross-Platform Analysis of Potentially Harmful Libraries on Android and iOS},
	author       = {K. Chen and X. Wang and Y. Chen and P. Wang and Y. Lee and X. Wang and B. Ma and A. Wang and Y. Zhang and W. Zou},
	year         = 2016,
	month        = may,
	booktitle    = {2016 IEEE Symposium on Security and Privacy (SP)},
	publisher    = {IEEE Computer Society},
	address      = {Los Alamitos, CA, USA},
	pages        = {357--376},
	doi          = {10.1109/SP.2016.29},
	issn         = {2375-1207},
	url          = {https://doi.ieeecomputersociety.org/10.1109/SP.2016.29},
	keywords     = {libraries;androids;humanoid robots;mobile communication;smart phones;security;google}
}
@inproceedings{10.1109/SP.2016.30,
	title        = {TriggerScope: Towards Detecting Logic Bombs in Android Applications},
	author       = {Fratantonio, Yanick and Bianchi, Antonio and Robertson, William and Kirda, Engin and Kruegel, Christopher and Vigna, Giovanni},
	year         = 2016,
	booktitle    = {2016 IEEE Symposium on Security and Privacy (SP)},
	pages        = {377--396},
	doi          = {10.1109/SP.2016.30}
}
@inproceedings{10.1109/SP40000.2020.00072,
	title        = {Automatic Uncovering of Hidden Behaviors From Input Validation in Mobile Apps},
	author       = {Zhao, Qingchuan and Zuo, Chaoshun and Dolan-Gavitt, Brendan and Pellegrino, Giancarlo and Lin, Zhiqiang},
	year         = 2020,
	booktitle    = {2020 IEEE Symposium on Security and Privacy (SP)},
	pages        = {1106--1120},
	doi          = {10.1109/SP40000.2020.00072}
}
@article{10.1109/TDSC.2019.2957787,
	title        = {Resilient User-Side Android Application Repackaging and Tampering Detection Using Cryptographically Obfuscated Logic Bombs},
	author       = {Zeng, Qiang and Luo, Lannan and Qian, Zhiyun and Du, Xiaojiang and Li, Zhoujun and Huang, Chin-Tser and Farkas, Csilla},
	year         = 2021,
	month        = nov,
	journal      = {IEEE Transactions on Dependable and Secure Computing},
	publisher    = {IEEE Computer Society Press},
	address      = {Washington, DC, USA},
	volume       = 18,
	number       = 6,
	pages        = {2582–2600},
	doi          = {10.1109/TDSC.2019.2957787},
	issn         = {1545-5971},
	url          = {https://doi.org/10.1109/TDSC.2019.2957787},
	issue_date   = {Nov.-Dec. 2021},
	abstract     = {Application repackaging is a severe threat to Android users and the market. Not only does it infringe on intellectual property, but it is also one of the most common ways of propagating mobile malware. Existing countermeasures mostly detect repackaging based on app similarity measurement, which tends to be imprecise when obfuscations are applied to repackaged apps. Moreover, they rely on a central party, typically the hosting app store, to perform the detection, but many app stores fail to commit proper effort to piracy detection. We consider building the application repackaging detection capability into apps, such that user devices are made use to detect repackaging in a decentralized fashion. <italic>The main challenge is how to protect the detection code from being manipulated by attacks</italic>. We propose a creative use of <italic>logic bombs</italic>, which are otherwise regularly used in malware. The <italic>trigger conditions</italic> of bombs are constructed to exploit the differences between the attacker and users, such that a bomb that lies dormant on the attacker side will be activated on the user side. The detection code, which is part of the bomb <italic>payload</italic>, is executed only if the bomb is activated. We introduce <italic>cryptographically obfuscated logic bomb</italic> to enhance the bomb: (1) the detection code is <italic>woven</italic> into the neighboring original app code, (2) the mixed code gets encrypted using a key, and (3) the key is deleted from the app and can only be derived when the bomb is activated. Thus, attacks that try to modify or delete the detection code will corrupt the app itself, and searching the key in the application will be in vain. Moreover, we propose a <italic>bomb spraying</italic> technique that allows many bombs to be injected into an app, multiplying the needed adversary effort for bypassing the detection. In addition to repackaging detection, we present application tampering detection to fight attacks that insert malicious code into repackaged apps. We have implemented a prototype, named <sc>BombDroid</sc>, that builds repackaging and tampering detection into apps through bytecode instrumentation. The evaluation and the security analysis show that the technique is effective, efficient, and resilient to various bomb analysis techniques including fuzzing, symbolic execution, multi-path exploration, and program slicing. Ethical issues due to the use of logic bombs are also discussed.},
	numpages     = 19
}
@article{10.1109/TDSC.2021.3108057,
	title        = {On The (In)Effectiveness of Static Logic Bomb Detector for Android Apps},
	author       = {Jordan Samhi and Alexandre Bartel},
	year         = 2021,
	month        = aug,
	journal      = {IEEE Transactions on Dependable and Secure Computing},
	publisher    = {IEEE Computer Society},
	address      = {Los Alamitos, CA, USA},
	number       = {01},
	pages        = {1--1},
	doi          = {10.1109/TDSC.2021.3108057},
	issn         = {1941-0018},
	keywords     = {weapons;malware;tools;java;internet;static analysis;open source software}
}
@article{10.1109/TIFS.2016.2523912,
	title        = {ICCDetector: ICC-Based Malware Detection on Android},
	author       = {Xu, Ke and Li, Yingjiu and Deng, Robert H.},
	year         = 2016,
	month        = jun,
	journal      = {IEEE Transactions on Information Forensics and Security},
	publisher    = {IEEE Press},
	volume       = 11,
	number       = 6,
	pages        = {1252–1264},
	doi          = {10.1109/TIFS.2016.2523912},
	issn         = {1556-6013},
	url          = {https://doi.org/10.1109/TIFS.2016.2523912},
	issue_date   = {June 2016},
	abstract     = {Most existing mobile malware detection methods (e.g., Kirin and DroidMat) are designed based on the resources required by malwares (e.g., permissions, application programming interface (API) calls, and system calls). These methods capture the interactions between mobile apps and Android system, but ignore the communications among components within or cross application boundaries. As a consequence, the majority of the existing methods are less effective in identifying many typical malwares, which require a few or no suspicious resources, but leverage on inter-component communication (ICC) mechanism when launching stealthy attacks. To address this challenge, we propose a new malware detection method, named ICCDetector. ICCDetector outputs a detection model after training with a set of benign apps and a set of malwares, and employs the trained model for malware detection. The performance of ICCDetector is evaluated with 5264 malwares, and 12026 benign apps. Compared with our benchmark, which is a permission-based method proposed by Peng et al. in 2012 with an accuracy up to 88.2\%, ICCDetector achieves an accuracy of 97.4\%, roughly 10\% higher than the benchmark, with a lower false positive rate of 0.67\%, which is only about a half of the benchmark. After manually analyzing false positives, we discover 43 new malwares from the benign data set, and reduce the number of false positives to seven. More importantly, ICCDetector discovers 1708 more advanced malwares than the benchmark, while it misses 220 obvious malwares, which can be easily detected by the benchmark. For the detected malwares, ICCDetector further classifies them into five newly defined malware categories, which help understand the relationship between malicious behaviors and ICC characteristics. We also provide a systemic analysis of ICC patterns of benign apps and malwares.},
	numpages     = 13
}
@article{10.1109/TIFS.2017.2656460,
	title        = {Understanding Android App Piggybacking: A Systematic Study of Malicious Code Grafting},
	author       = {Li and Li, Daoyuan and Bissyande, Tegawende F. and Klein, Jacques and Le Traon, Yves and Lo, David and Cavallaro, Lorenzo},
	year         = 2017,
	month        = jun,
	journal      = {IEEE Transactions on Information Forensics and Security},
	publisher    = {IEEE Press},
	volume       = 12,
	number       = 6,
	pages        = {1269–1284},
	doi          = {10.1109/TIFS.2017.2656460},
	issn         = {1556-6013},
	url          = {https://doi.org/10.1109/TIFS.2017.2656460},
	issue_date   = {June 2017},
	abstract     = {The Android packaging model offers ample opportunities for malware writers to piggyback malicious code in popular apps, which can then be easily spread to a large user base. Although recent research has produced approaches and tools to identify piggybacked apps, the literature lacks a comprehensive investigation into such phenomenon. We fill this gap by: 1) systematically building a large set of piggybacked and benign apps pairs, which we release to the community; 2) empirically studying the characteristics of malicious piggybacked apps in comparison with their benign counterparts; and 3) providing insights on piggybacking processes. Among several findings providing insights analysis techniques should build upon to improve the overall detection and classification accuracy of piggybacked apps, we show that piggybacking operations not only concern app code, but also extensively manipulates app resource files, largely contradicting common beliefs. We also find that piggybacking is done with little sophistication, in many cases automatically, and often via library code.},
	numpages     = 16
}
@article{10.1109/TIFS.2017.2661723,
	title        = {Auditing Anti-Malware Tools by Evolving Android Malware and Dynamic Loading Technique},
	author       = {Xue, Yinxing and Meng, Guozhu and Liu, Yang and Tan, Tian Huat and Chen, Hongxu and Sun, Jun and Zhang, Jie},
	year         = 2017,
	month        = jul,
	journal      = {IEEE Transactions on Information Forensics and Security},
	publisher    = {IEEE Press},
	volume       = 12,
	number       = 7,
	pages        = {1529–1544},
	doi          = {10.1109/TIFS.2017.2661723},
	issn         = {1556-6013},
	url          = {https://doi.org/10.1109/TIFS.2017.2661723},
	issue_date   = {July 2017},
	abstract     = {Although a previous paper shows that existing anti-malware tools (AMTs) may have high detection rate, the report is based on existing malware and thus it does not imply that AMTs can effectively deal with future malware. It is desirable to have an alternative way of auditing AMTs. In our previous paper, we use malware samples from android malware collection Genome to summarize a malware meta-model for modularizing the common attack behaviors and evasion techniques in reusable features. We then combine different features with an evolutionary algorithm, in which way we evolve malware for variants. Previous results have shown that the existing AMTs only exhibit detection rate of 20\%–30\% for 10 000 evolved malware variants. In this paper, based on the modularized attack features, we apply the dynamic code generation and loading techniques to produce malware, so that we can audit the AMTs at runtime. We implement our approach, named Mystique-S, as a service-oriented malware generation system. Mystique-S automatically selects attack features under various user scenarios and delivers the corresponding malicious payloads at runtime. Relying on dynamic code binding (via service) and loading (via reflection) techniques, Mystique-S enables dynamic execution of payloads on user devices at runtime. Experimental results on real-world devices show that existing AMTs are incapable of detecting most of our generated malware. Last, we propose the enhancements for existing AMTs.},
	numpages     = 16
}
@article{10.1109/TR.2018.2865733,
	title        = {Automated Testing of Android Apps: A Systematic Literature Review},
	author       = {Kong, Pingfan and Li, Li and Gao, Jun and Liu, Kui and Bissyandé, Tegawendé F. and Klein, Jacques},
	year         = 2019,
	journal      = {IEEE Transactions on Reliability},
	volume       = 68,
	number       = 1,
	pages        = {45--66},
	doi          = {10.1109/TR.2018.2865733}
}
@inproceedings{10.1109/Trustcom/BigDataSE/ICESS.2017.230,
	title        = {SimiDroid: Identifying and Explaining Similarities in Android Apps},
	author       = {L. {Li} and T. F. {Bissyandé} and J. {Klein}},
	year         = 2017,
	booktitle    = {2017 IEEE Trustcom/BigDataSE/ICESS},
	pages        = {136--143},
	doi          = {10.1109/Trustcom/BigDataSE/ICESS.2017.230}
}
@article{10.1109/TSE.2019.2901679,
	title        = {Rebooting Research on Detecting Repackaged Android Apps: Literature Review and Benchmark},
	author       = {L. Li and T. F. Bissyande and J. Klein},
	year         = 2021,
	month        = apr,
	journal      = {IEEE Transactions on Software Engineering},
	publisher    = {IEEE Computer Society},
	address      = {Los Alamitos, CA, USA},
	volume       = 47,
	number       = {04},
	pages        = {676--693},
	doi          = {10.1109/TSE.2019.2901679},
	issn         = {1939-3520},
	keywords     = {bibliographies;malware;cloning;systematics;tools;aging;libraries}
}
@inproceedings{10.1109/WCSE.2012.26,
	title        = {LeakMiner: Detect Information Leakage on Android with Static Taint Analysis},
	author       = {Yang, Zhemin and Yang, Min},
	year         = 2012,
	booktitle    = {2012 Third World Congress on Software Engineering},
	pages        = {101--104},
	doi          = {10.1109/WCSE.2012.26}
}
@inproceedings{10.1145/1065010.1065019,
	title        = {Checking Type Safety of Foreign Function Calls},
	author       = {Furr, Michael and Foster, Jeffrey S.},
	year         = 2005,
	booktitle    = {Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation},
	location     = {Chicago, IL, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {PLDI '05},
	pages        = {62–72},
	doi          = {10.1145/1065010.1065019},
	isbn         = 1595930566,
	url          = {https://doi.org/10.1145/1065010.1065019},
	abstract     = {We present a multi-lingual type inference system for checking type safety across a foreign function interface. The goal of our system is to prevent foreign function calls from introducing type and memory safety violations into an otherwise safe language. Our system targets OCaml's FFI to C, which is relatively lightweight and illustrates some interesting challenges in multi-lingual type inference. The type language in our system embeds OCaml types in C types and vice-versa, which allows us to track type information accurately even through the foreign language, where the original types are lost. Our system uses representational types that can model multiple OCaml types, because C programs can observe that many OCaml types have the same physical representation. Furthermore, because C has a low-level view of OCaml data, our inference system includes a dataflow analysis to track memory offsets and tag information. Finally, our type system includes garbage collection information to ensure that pointers from the FFI to the OCaml heap are tracked properly. We have implemented our inference system and applied it to a small set of benchmarks. Our results show that programmers do misuse these interfaces, and our implementation has found several bugs and questionable coding practices in our benchmarks.},
	numpages     = 11,
	keywords     = {flow-sensitive type system, FFI, OCaml, foreign function calls, foreign function interface, dataflow analysis, representational type, multi-lingual type inference, multi-lingual type system}
}
@article{10.1145/1127577.1127590,
	title        = {Practical Analysis of Stripped Binary Code},
	author       = {Harris, Laune C. and Miller, Barton P.},
	year         = 2005,
	month        = dec,
	journal      = {ACM SIGARCH Computer Architecture News},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 33,
	number       = 5,
	pages        = {63–68},
	doi          = {10.1145/1127577.1127590},
	issn         = {0163-5964},
	url          = {https://doi.org/10.1145/1127577.1127590},
	issue_date   = {December 2005},
	abstract     = {Executable binary code is the authoritative source of information about program content and behavior. The compile, link, and optimize steps can cause a program's detailed execution behavior to differ substantially from its source code. Binary code analysis is used to provide information about a program's content and structure, and is therefore a foundation of many applications, including binary modification[3,12,22,31], binary translation[5,29], binary matching[30], performance profiling[13,16,18], debugging, extraction of parameters for performance modeling, computer security[7,8] and forensics[23,26]. Ideally, binary analysis should produce information about the content of the program's code (instructions, basic blocks, functions, and modules), structure (control and data flow), and data structures (global and stack variables). The quality and availability of this information affects applications that rely on binary analysis.},
	numpages     = 6
}
@article{10.1145/1541880.1541882,
	title        = {Anomaly Detection: A Survey},
	author       = {Chandola, Varun and Banerjee, Arindam and Kumar, Vipin},
	year         = 2009,
	month        = jul,
	journal      = {ACM Computing Surveys},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 41,
	number       = 3,
	doi          = {10.1145/1541880.1541882},
	issn         = {0360-0300},
	url          = {https://doi.org/10.1145/1541880.1541882},
	issue_date   = {July 2009},
	abstract     = {Anomaly detection is an important problem that has been researched within diverse research areas and application domains. Many anomaly detection techniques have been specifically developed for certain application domains, while others are more generic. This survey tries to provide a structured and comprehensive overview of the research on anomaly detection. We have grouped existing techniques into different categories based on the underlying approach adopted by each technique. For each category we have identified key assumptions, which are used by the techniques to differentiate between normal and anomalous behavior. When applying a given technique to a particular domain, these assumptions can be used as guidelines to assess the effectiveness of the technique in that domain. For each category, we provide a basic anomaly detection technique, and then show how the different existing techniques in that category are variants of the basic technique. This template provides an easier and more succinct understanding of the techniques belonging to each category. Further, for each category, we identify the advantages and disadvantages of the techniques in that category. We also provide a discussion on the computational complexity of the techniques since it is an important issue in real application domains. We hope that this survey will provide a better understanding of the different directions in which research has been done on this topic, and how techniques developed in one area can be applied in domains for which they were not intended to begin with.},
	articleno    = 15,
	numpages     = 58,
	keywords     = {Anomaly detection, outlier detection}
}
@article{10.1145/1961189.1961199,
	title        = {LIBSVM: A Library for Support Vector Machines},
	author       = {Chang, Chih-Chung and Lin, Chih-Jen},
	year         = 2011,
	month        = may,
	journal      = {ACM Transactions on Intelligent Systems and Technology},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 2,
	number       = 3,
	doi          = {10.1145/1961189.1961199},
	issn         = {2157-6904},
	url          = {https://doi.org/10.1145/1961189.1961199},
	issue_date   = {April 2011},
	abstract     = {LIBSVM is a library for Support Vector Machines (SVMs). We have been actively developing this package since the year 2000. The goal is to help users to easily apply SVM to their applications. LIBSVM has gained wide popularity in machine learning and many other areas. In this article, we present all implementation details of LIBSVM. Issues such as solving SVM optimization problems theoretical convergence multiclass classification probability estimates and parameter selection are discussed in detail.},
	articleno    = 27,
	numpages     = 27,
	keywords     = {Classification LIBSVM optimization regression support vector machines SVM}
}
@inproceedings{10.1145/1985793.1985827,
	title        = {Taming Reflection: Aiding Static Analysis in the Presence of Reflection and Custom Class Loaders},
	author       = {Bodden, Eric and Sewe, Andreas and Sinschek, Jan and Oueslati, Hela and Mezini, Mira},
	year         = 2011,
	booktitle    = {Proceedings of the 33rd International Conference on Software Engineering},
	location     = {Waikiki, Honolulu, HI, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ICSE '11},
	pages        = {241–250},
	doi          = {10.1145/1985793.1985827},
	isbn         = 9781450304450,
	url          = {https://doi.org/10.1145/1985793.1985827},
	abstract     = {Static program analyses and transformations for Java face many problems when analyzing programs that use reflection or custom class loaders: How can a static analysis know which reflective calls the program will execute? How can it get hold of classes that the program loads from remote locations or even generates on the fly? And if the analysis transforms classes, how can these classes be re-inserted into a program that uses custom class loaders?In this paper, we present TamiFlex, a tool chain that offers a partial but often effective solution to these problems. With TamiFlex, programmers can use existing static-analysis tools to produce results that are sound at least with respect to a set of recorded program runs. TamiFlex inserts runtime checks into the program that warn the user in case the program executes reflective calls that the analysis did not take into account. TamiFlex further allows programmers to re-insert offline-transformed classes into a program.We evaluate TamiFlex in two scenarios: benchmarking with the DaCapo benchmark suite and analysing large-scale interactive applications. For the latter, TamiFlex significantly improves code coverage of the static analyses, while for the former our approach even appears complete: the inserted runtime checks issue no warning. Hence, for the first time, TamiFlex enables sound static whole-program analyses on DaCapo. During this process, TamiFlex usually incurs less than 10% runtime overhead.},
	numpages     = 10,
	keywords     = {tracing, native code, dynamic class loaders, dynamic class loading, static analysis, reflection}
}
@inproceedings{10.1145/1999995.2000018,
	title        = {Analyzing Inter-Application Communication in Android},
	author       = {Chin, Erika and Felt, Adrienne Porter and Greenwood, Kate and Wagner, David},
	year         = 2011,
	booktitle    = {Proceedings of the 9th International Conference on Mobile Systems, Applications, and Services},
	location     = {Bethesda, Maryland, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {MobiSys '11},
	pages        = {239–252},
	doi          = {10.1145/1999995.2000018},
	isbn         = 9781450306430,
	url          = {https://doi.org/10.1145/1999995.2000018},
	abstract     = {Modern smartphone operating systems support the development of third-party applications with open system APIs. In addition to an open API, the Android operating system also provides a rich inter-application message passing system. This encourages inter-application collaboration and reduces developer burden by facilitating component reuse. Unfortunately, message passing is also an application attack surface. The content of messages can be sniffed, modified, stolen, or replaced, which can compromise user privacy. Also, a malicious application can inject forged or otherwise malicious messages, which can lead to breaches of user data and violate application security policies.We examine Android application interaction and identify security risks in application components. We provide a tool, ComDroid, that detects application communication vulnerabilities. ComDroid can be used by developers to analyze their own applications before release, by application reviewers to analyze applications in the Android Market, and by end users. We analyzed 20 applications with the help of ComDroid and found 34 exploitable vulnerabilities; 12 of the 20 applications have at least one vulnerability.},
	numpages     = 14,
	keywords     = {message passing, Android, intents, mobile phone security}
}
@inproceedings{10.1145/2046614.2046619,
	title        = {Crowdroid: Behavior-Based Malware Detection System for Android},
	author       = {Burguera, Iker and Zurutuza, Urko and Nadjm-Tehrani, Simin},
	year         = 2011,
	booktitle    = {Proceedings of the 1st ACM Workshop on Security and Privacy in Smartphones and Mobile Devices},
	location     = {Chicago, Illinois, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {SPSM '11},
	pages        = {15–26},
	doi          = {10.1145/2046614.2046619},
	isbn         = 9781450310000,
	url          = {https://doi.org/10.1145/2046614.2046619},
	abstract     = {The sharp increase in the number of smartphones on the market, with the Android platform posed to becoming a market leader makes the need for malware analysis on this platform an urgent issue.In this paper we capitalize on earlier approaches for dynamic analysis of application behavior as a means for detecting malware in the Android platform. The detector is embedded in a overall framework for collection of traces from an unlimited number of real users based on crowdsourcing. Our framework has been demonstrated by analyzing the data collected in the central server using two types of data sets: those from artificial malware created for test purposes, and those from real malware found in the wild. The method is shown to be an effective means of isolating the malware and alerting the users of a downloaded malware. This shows the potential for avoiding the spreading of a detected malware to a larger community.},
	numpages     = 12,
	keywords     = {smartphone security, data mining, dynamic analysis, crowdsourcing, intrusion detection, anomaly detection, malware detection}
}
@inproceedings{10.1145/2046707.2046780,
	title        = {These Aren't the Droids You're Looking for: Retrofitting Android to Protect Data from Imperious Applications},
	author       = {Hornyack, Peter and Han, Seungyeop and Jung, Jaeyeon and Schechter, Stuart and Wetherall, David},
	year         = 2011,
	booktitle    = {Proceedings of the 18th ACM Conference on Computer and Communications Security},
	location     = {Chicago, Illinois, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {CCS '11},
	pages        = {639–652},
	doi          = {10.1145/2046707.2046780},
	isbn         = 9781450309486,
	url          = {https://doi.org/10.1145/2046707.2046780},
	abstract     = {We examine two privacy controls for Android smartphones that empower users to run permission-hungry applications while protecting private data from being exfiltrated: (1) covertly substituting shadow data in place of data that the user wants to keep private, and (2) blocking network transmissions that contain data the user made available to the application for on-device use only. We retrofit the Android operating system to implement these two controls for use with unmodified applications. A key challenge of imposing shadowing and exfiltration blocking on existing applications is that these controls could cause side effects that interfere with user-desired functionality. To measure the impact of side effects, we develop an automated testing methodology that records screenshots of application executions both with and without privacy controls, then automatically highlights the visual differences between the different executions. We evaluate our privacy controls on 50 applications from the Android Market, selected from those that were both popular and permission-hungry. We find that our privacy controls can successfully reduce the effective permissions of the application without causing side effects for 66% of the tested applications. The remaining 34% of applications implemented user-desired functionality that required violating the privacy requirements our controls were designed to enforce; there was an unavoidable choice between privacy and user-desired functionality.},
	numpages     = 14,
	keywords     = {android, privacy, smartphone}
}
@inproceedings{10.1145/2245276.2232009,
	title        = {A Framework for Static Detection of Privacy Leaks in Android Applications},
	author       = {Mann, Christopher and Starostin, Artem},
	year         = 2012,
	booktitle    = {Proceedings of the 27th Annual ACM Symposium on Applied Computing},
	location     = {Trento, Italy},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {SAC '12},
	pages        = {1457–1462},
	doi          = {10.1145/2245276.2232009},
	isbn         = 9781450308571,
	url          = {https://doi.org/10.1145/2245276.2232009},
	abstract     = {We report on applying techniques for static information flow analysis to identify privacy leaks in Android applications. We have crafted a framework which checks with the help of a security type system whether the Dalvik bytecode implementation of an Android app conforms to a given privacy policy. We have carefully analyzed the Android API for possible sources and sinks of private data and identified exemplary privacy policies based on this. We demonstrate the applicability of our framework on two case studies showing detection of privacy leaks.},
	numpages     = 6,
	keywords     = {android, privacy, static analysis, information flow security}
}
@inproceedings{10.1145/2259051.2259056,
	title        = {Dexpler: Converting Android Dalvik Bytecode to Jimple for Static Analysis with Soot},
	author       = {Bartel, Alexandre and Klein, Jacques and Le Traon, Yves and Monperrus, Martin},
	year         = 2012,
	booktitle    = {Proceedings of the ACM SIGPLAN International Workshop on State of the Art in Java Program Analysis},
	location     = {Beijing, China},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {SOAP '12},
	pages        = {27–38},
	doi          = {10.1145/2259051.2259056},
	isbn         = 9781450314909,
	url          = {https://doi.org/10.1145/2259051.2259056},
	abstract     = {This paper introduces Dexpler, a software package which converts Dalvik bytecode to Jimple. Dexpler is built on top of Dedexer and Soot. As Jimple is Soot's main internal representation of code, the Dalvik bytecode can be manipulated with any Jimple based tool, for instance for performing point-to or flow analysis.},
	numpages     = 12,
	keywords     = {Jimple, Android, static analysis, Dalvik bytecode, code generation, Soot}
}
@inproceedings{10.1145/2259051.2259052,
	title        = {Inter-Procedural Data-Flow Analysis with IFDS/IDE and Soot},
	author       = {Bodden, Eric},
	year         = 2012,
	booktitle    = {Proceedings of the ACM SIGPLAN International Workshop on State of the Art in Java Program Analysis},
	location     = {Beijing, China},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {SOAP '12},
	pages        = {3–8},
	doi          = {10.1145/2259051.2259052},
	isbn         = 9781450314909,
	url          = {https://doi.org/10.1145/2259051.2259052},
	abstract     = {The IFDS and IDE frameworks by Reps, Horwitz and Sagiv are two general frameworks for the inter-procedural analysis of data-flow problems with distributive flow functions over finite domains. Many data-flow problems do have distributive flow functions and are thus expressible as IFDS or IDE problems, reaching from basic analyses like truly-live variables to complex analyses for problems from the current literature such as typestate and secure information-flow.In this work we describe our implementation of a generic IFDS/IDE solver on top of Soot and contrast it with an IFDS implementation in the Watson Libraries for Analysis (WALA), both from a user's perspective and in terms of the implementation. While WALA's implementation is geared much towards memory efficiency, ours is currently geared more towards extensibility and ease of use and we focus on efficiency as a secondary goal.We further discuss possible extensions to our IFDS/IDE implementation that may be useful to support a wider range of analyses.},
	numpages     = 6,
	keywords     = {IFDS, IDE, inter-procedural static analysis, flow-sensitive analysis}
}
@inproceedings{10.1145/3510003.3510161,
	title        = {Rotten Apples Spoil the Bunch: An Anatomy of Google Play Malware},
	author       = {Cao, Michael and Ahmed, Khaled and Rubin, Julia},
	year         = 2022,
	booktitle    = {Proceedings of the 44th International Conference on Software Engineering},
	location     = {Pittsburgh, Pennsylvania},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ICSE '22},
	pages        = {1919–1931},
	doi          = {10.1145/3510003.3510161},
	isbn         = 9781450392211,
	url          = {https://doi.org/10.1145/3510003.3510161},
	abstract     = {This paper provides an in-depth analysis of Android malware that bypassed the strictest defenses of the Google Play application store and penetrated the official Android market between January 2016 and July 2021. We systematically identified 1,238 such malicious applications, grouped them into 134 families, and manually analyzed one application from 105 distinct families. During our manual analysis, we identified malicious payloads the applications execute, conditions guarding execution of the payloads, hiding techniques applications employ to evade detection by the user, and other implementation-level properties relevant for automated malware detection. As most applications in our dataset contain multiple payloads, each triggered via its own complex activation logic, we also contribute a graph-based representation showing activation paths for all application payloads in form of a control- and data-flow graph. Furthermore, we discuss the capabilities of existing malware detection tools, put them in context of the properties observed in the analyzed malware, and identify gaps and future research directions. We believe that our detailed analysis of the recent, evasive malware will be of interest to researchers and practitioners and will help further improve malware detection tools.},
	numpages     = 13,
	keywords     = {malware, manual analysis, dataset, Android, malware detection}
}
@inproceedings{10.1145/2307636.2307663,
	title        = {RiskRanker: Scalable and Accurate Zero-Day Android Malware Detection},
	author       = {Grace, Michael and Zhou, Yajin and Zhang, Qiang and Zou, Shihong and Jiang, Xuxian},
	year         = 2012,
	booktitle    = {Proceedings of the 10th International Conference on Mobile Systems, Applications, and Services},
	location     = {Low Wood Bay, Lake District, UK},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {MobiSys '12},
	pages        = {281–294},
	doi          = {10.1145/2307636.2307663},
	isbn         = 9781450313018,
	url          = {https://doi.org/10.1145/2307636.2307663},
	abstract     = {Smartphone sales have recently experienced explosive growth. Their popularity also encourages malware authors to penetrate various mobile marketplaces with malicious applications (or apps). These malicious apps hide in the sheer number of other normal apps, which makes their detection challenging. Existing mobile anti-virus software are inadequate in their reactive nature by relying on known malware samples for signature extraction. In this paper, we propose a proactive scheme to spot zero-day Android malware. Without relying on malware samples and their signatures, our scheme is motivated to assess potential security risks posed by these untrusted apps. Specifically, we have developed an automated system called RiskRanker to scalably analyze whether a particular app exhibits dangerous behavior (e.g., launching a root exploit or sending background SMS messages). The output is then used to produce a prioritized list of reduced apps that merit further investigation. When applied to examine 118,318 total apps collected from various Android markets over September and October 2011, our system takes less than four days to process all of them and effectively reports 3281 risky apps. Among these reported apps, we successfully uncovered 718 malware samples (in 29 families) and 322 of them are zero-day (in 11 families). These results demonstrate the efficacy and scalability of RiskRanker to police Android markets of all stripes.},
	numpages     = 14,
	keywords     = {android, riskranker, malware}
}
@inproceedings{10.1145/236337.236371,
	title        = {Fast Static Analysis of C++ Virtual Function Calls},
	author       = {Bacon, David F. and Sweeney, Peter F.},
	year         = 1996,
	booktitle    = {Proceedings of the 11th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
	location     = {San Jose, California, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {OOPSLA '96},
	pages        = {324–341},
	doi          = {10.1145/236337.236371},
	isbn         = {089791788X},
	url          = {https://doi.org/10.1145/236337.236371},
	abstract     = {Virtual functions make code easier for programmers to reuse but also make it harder for compilers to analyze. We investigate the ability of three static analysis algorithms to improve C++ programs by resolving virtual function calls, thereby reducing compiled code size and reducing program complexity so as to improve both human and automated program understanding and analysis. In measurements of seven programs of significant size (5000 to 20000 lines of code each) we found that on average the most precise of the three algorithms resolved 71\% of the virtual function calls and reduced compiled code size by 25\%. This algorithm is very fast: it analyzes 3300 source lines per second on an 80 MHz PowerPC 601. Because of its accuracy and speed, this algorithm is an excellent candidate for inclusion in production C++ compilers.},
	numpages     = 18
}
@article{10.1145/236338.236371,
	title        = {Fast Static Analysis of C++ Virtual Function Calls},
	author       = {Bacon, David F. and Sweeney, Peter F.},
	year         = 1996,
	month        = oct,
	journal      = {ACM SIGPLAN NOTICES},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 31,
	number       = 10,
	pages        = {324–341},
	doi          = {10.1145/236338.236371},
	issn         = {0362-1340},
	url          = {https://doi.org/10.1145/236338.236371},
	issue_date   = {Oct. 1996},
	abstract     = {Virtual functions make code easier for programmers to reuse but also make it harder for compilers to analyze. We investigate the ability of three static analysis algorithms to improve C++ programs by resolving virtual function calls, thereby reducing compiled code size and reducing program complexity so as to improve both human and automated program understanding and analysis. In measurements of seven programs of significant size (5000 to 20000 lines of code each) we found that on average the most precise of the three algorithms resolved 71\% of the virtual function calls and reduced compiled code size by 25\%. This algorithm is very fast: it analyzes 3300 source lines per second on an 80 MHz PowerPC 601. Because of its accuracy and speed, this algorithm is an excellent candidate for inclusion in production C++ compilers.},
	numpages     = 18
}
@article{10.1109/TSE.1979.234183,
	title        = {Constructing the Call Graph of a Program},
	author       = {Ryder, B.G.},
	year         = 1979,
	journal      = {IEEE Transactions on Software Engineering},
	volume       = {SE-5},
	number       = 3,
	pages        = {216--226},
	doi          = {10.1109/TSE.1979.234183}
}
@inproceedings{10.1145/2381934.2381950,
	title        = {SmartDroid: An Automatic System for Revealing UI-Based Trigger Conditions in Android Applications},
	author       = {Zheng, Cong and Zhu, Shixiong and Dai, Shuaifu and Gu, Guofei and Gong, Xiaorui and Han, Xinhui and Zou, Wei},
	year         = 2012,
	booktitle    = {Proceedings of the Second ACM Workshop on Security and Privacy in Smartphones and Mobile Devices},
	location     = {Raleigh, North Carolina, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {SPSM '12},
	pages        = {93–104},
	doi          = {10.1145/2381934.2381950},
	isbn         = 9781450316668,
	url          = {https://doi.org/10.1145/2381934.2381950},
	abstract     = {User interface (UI) interactions are essential to Android applications, as many Activities require UI interactions to be triggered. This kind of UI interactions could also help malicious apps to hide their sensitive behaviors (e.g., sending SMS or getting the user's device ID) from being detected by dynamic analysis tools such as TaintDroid, because simply running the app, but without proper UI interactions, will not lead to the exposure of sensitive behaviors. In this paper we focus on the challenging task of triggering a certain behavior through automated UI interactions. In particular, we propose a hybrid static and dynamic analysis method to reveal UI-based trigger conditions in Android applications. Our method first uses static analysis to extract expected activity switch paths by analyzing both Activity and Function Call Graphs, and then uses dynamic analysis to traverse each UI elements and explore the UI interaction paths towards the sensitive APIs. We implement a prototype system SmartDroid and show that it can automatically and efficiently detect the UI-based trigger conditions required to expose the sensitive behavior of several Android malwares, which otherwise cannot be detected with existing techniques such as TaintDroid.},
	numpages     = 12,
	keywords     = {sensitive behavior, smartphone security, ui-based trigger condition, android}
}
@inproceedings{10.1145/2382196.2382222,
	title        = {PScout: Analyzing the Android Permission Specification},
	author       = {Au, Kathy Wain Yee and Zhou, Yi Fan and Huang, Zhen and Lie, David},
	year         = 2012,
	booktitle    = {Proceedings of the 2012 ACM Conference on Computer and Communications Security},
	location     = {Raleigh, North Carolina, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {CCS '12},
	pages        = {217–228},
	doi          = {10.1145/2382196.2382222},
	isbn         = 9781450316514,
	url          = {https://doi.org/10.1145/2382196.2382222},
	abstract     = {Modern smartphone operating systems (OSs) have been developed with a greater emphasis on security and protecting privacy. One of the mechanisms these systems use to protect users is a permission system, which requires developers to declare what sensitive resources their applications will use, has users agree with this request when they install the application and constrains the application to the requested resources during runtime. As these permission systems become more common, questions have risen about their design and implementation. In this paper, we perform an analysis of the permission system of the Android smartphone OS in an attempt to begin answering some of these questions. Because the documentation of Android's permission system is incomplete and because we wanted to be able to analyze several versions of Android, we developed PScout, a tool that extracts the permission specification from the Android OS source code using static analysis. PScout overcomes several challenges, such as scalability due to Android's 3.4 million line code base, accounting for permission enforcement across processes due to Android's use of IPC, and abstracting Android's diverse permission checking mechanisms into a single primitive for analysis.We use PScout to analyze 4 versions of Android spanning version 2.2 up to the recently released Android 4.0. Our main findings are that while Android has over 75 permissions, there is little redundancy in the permission specification. However, if applications could be constrained to only use documented APIs, then about 22\% of the non-system permissions are actually unnecessary. Finally, we find that a trade-off exists between enabling least-privilege security with fine-grained permissions and maintaining stability of the permission specification as the Android OS evolves.},
	numpages     = 12,
	keywords     = {android, smartphone, permissions}
}
@inproceedings{10.1145/2484313.2484315,
	title        = {AppInk: Watermarking Android Apps for Repackaging Deterrence},
	author       = {Zhou, Wu and Zhang, Xinwen and Jiang, Xuxian},
	year         = 2013,
	booktitle    = {Proceedings of the 8th ACM SIGSAC Symposium on Information, Computer and Communications Security},
	location     = {Hangzhou, China},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ASIA CCS '13},
	pages        = {1–12},
	doi          = {10.1145/2484313.2484315},
	isbn         = 9781450317672,
	url          = {https://doi.org/10.1145/2484313.2484315},
	abstract     = {With increased popularity and wide adoption of smartphones and mobile devices, recent years have seen a new burgeoning economy model centered around mobile apps. However, app repackaging, among many other threats, brings tremendous risk to the ecosystem, including app developers, app market operators, and end users. To mitigate such threat, we propose and develop a watermarking mechanism for Android apps. First, towards automatic watermark embedding and extraction, we introduce the novel concept of manifest app, which is a companion of a target Android app under protection. We then design and develop a tool named AppInk, which takes the source code of an app as input to automatically generate a new app with a transparently-embedded watermark and the associated manifest app. The manifest app can be later used to reliably recognize embedded watermark with zero user intervention. To demonstrate the effectiveness of AppInk in preventing app repackaging, we analyze its robustness in defending against distortive, subtractive, and additive attacks, and then evaluate its resistance against two open source repackaging tools. Our results show that AppInk is easy to use, effective in defending against current known repackaging threats on Android platform, and introduces small performance overhead.},
	numpages     = 12,
	keywords     = {smartphone security, app protection, software watermarking, mobile application, app repackaging}
}
@inproceedings{10.1145/2592791.2592796,
	title        = {Rage against the Virtual Machine: Hindering Dynamic Analysis of Android Malware},
	author       = {Petsas, Thanasis and Voyatzis, Giannis and Athanasopoulos, Elias and Polychronakis, Michalis and Ioannidis, Sotiris},
	year         = 2014,
	booktitle    = {Proceedings of the Seventh European Workshop on System Security},
	location     = {Amsterdam, The Netherlands},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {EuroSec '14},
	doi          = {10.1145/2592791.2592796},
	isbn         = 9781450327152,
	url          = {https://doi.org/10.1145/2592791.2592796},
	abstract     = {Antivirus companies, mobile application marketplaces, and the security research community, employ techniques based on dynamic code analysis to detect and analyze mobile malware. In this paper, we present a broad range of anti-analysis techniques that malware can employ to evade dynamic analysis in emulated Android environments. Our detection heuristics span three different categories based on (i) static properties, (ii) dynamic sensor information, and (iii) VM-related intricacies of the Android Emulator. To assess the effectiveness of our techniques, we incorporated them in real malware samples and submitted them to publicly available Android dynamic analysis systems, with alarming results. We found all tools and services to be vulnerable to most of our evasion techniques. Even trivial techniques, such as checking the value of the IMEI, are enough to evade some of the existing dynamic analysis frameworks. We propose possible countermeasures to improve the resistance of current dynamic analysis tools against evasion attempts.},
	articleno    = 5,
	numpages     = 6
}
@inproceedings{10.1145/2594291.2594311,
	title        = {Race Detection for Android Applications},
	author       = {Maiya, Pallavi and Kanade, Aditya and Majumdar, Rupak},
	year         = 2014,
	booktitle    = {Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},
	location     = {Edinburgh, United Kingdom},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {PLDI '14},
	pages        = {316–325},
	doi          = {10.1145/2594291.2594311},
	isbn         = 9781450327848,
	url          = {https://doi.org/10.1145/2594291.2594311},
	abstract     = {Programming environments for smartphones expose a concurrency model that combines multi-threading and asynchronous event-based dispatch. While this enables the development of efficient and feature-rich applications, unforeseen thread interleavings coupled with non-deterministic reorderings of asynchronous tasks can lead to subtle concurrency errors in the applications.In this paper, we formalize the concurrency semantics of the Android programming model. We further define the happens-before relation for Android applications, and develop a dynamic race detection technique based on this relation. Our relation generalizes the so far independently studied happens-before relations for multi-threaded programs and single-threaded event-driven programs. Additionally, our race detection technique uses a model of the Android runtime environment to reduce false positives.We have implemented a tool called DroidRacer. It generates execution traces by systematically testing Android applications and detects data races by computing the happens-before relation on the traces. We analyzed 15 Android applications including popular applications such as Facebook, Twitter and K-9 Mail. Our results indicate that data races are prevalent in Android applications, and that DroidRacer is an effective tool to identify data races.},
	numpages     = 10,
	keywords     = {Android concurrency semantics, happens-before reasoning, data races}
}
@inproceedings{10.1145/2597073.2597109,
	title        = {Revisiting Android Reuse Studies in the Context of Code Obfuscation and Library Usages},
	author       = {Linares-V\'{a}squez, Mario and Holtzhauer, Andrew and Bernal-C\'{a}rdenas, Carlos and Poshyvanyk, Denys},
	year         = 2014,
	booktitle    = {Proceedings of the 11th Working Conference on Mining Software Repositories},
	location     = {Hyderabad, India},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {MSR 2014},
	pages        = {242–251},
	doi          = {10.1145/2597073.2597109},
	isbn         = 9781450328630,
	url          = {https://doi.org/10.1145/2597073.2597109},
	abstract     = {In the recent years, studies of design and programming practices in mobile development are gaining more attention from researchers. Several such empirical studies used Android applications (paid, free, and open source) to analyze factors such as size, quality, dependencies, reuse, and cloning. Most of the studies use executable files of the apps (APK files), instead of source code because of availability issues (most of free apps available at the Android official market are not open-source, but still can be downloaded and analyzed in APK format). However, using only APK files in empirical studies comes with some threats to the validity of the results. In this paper, we analyze some of these pertinent threats. In particular, we analyzed the impact of third-party libraries and code obfuscation practices on estimating the amount of reuse by class cloning in Android apps. When including and excluding third-party libraries from the analysis, we found statistically significant differences in the amount of class cloning 24,379 free Android apps. Also, we found some evidence that obfuscation is responsible for increasing a number of false positives when detecting class clones. Finally, based on our findings, we provide a list of actionable guidelines for mining and analyzing large repositories of Android applications and minimizing these threats to validity},
	numpages     = 10,
	keywords     = {reuse, Android, class cloning, obfuscated code, third-party libraries}
}
@article{10.1145/2619091,
	title        = {TaintDroid: An Information-Flow Tracking System for Realtime Privacy Monitoring on Smartphones},
	author       = {Enck, William and Gilbert, Peter and Han, Seungyeop and Tendulkar, Vasant and Chun, Byung-Gon and Cox, Landon P. and Jung, Jaeyeon and McDaniel, Patrick and Sheth, Anmol N.},
	year         = 2014,
	month        = jun,
	journal      = {ACM Transactions on Computer Systems},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 32,
	number       = 2,
	doi          = {10.1145/2619091},
	issn         = {0734-2071},
	url          = {https://doi.org/10.1145/2619091},
	issue_date   = {June 2014},
	abstract     = {Today’s smartphone operating systems frequently fail to provide users with visibility into how third-party applications collect and share their private data. We address these shortcomings with TaintDroid, an efficient, system-wide dynamic taint tracking and analysis system capable of simultaneously tracking multiple sources of sensitive data. TaintDroid enables realtime analysis by leveraging Android’s virtualized execution environment. TaintDroid incurs only 32\% performance overhead on a CPU-bound microbenchmark and imposes negligible overhead on interactive third-party applications. Using TaintDroid to monitor the behavior of 30 popular third-party Android applications, in our 2010 study we found 20 applications potentially misused users’ private information; so did a similar fraction of the tested applications in our 2012 study. Monitoring the flow of privacy-sensitive data with TaintDroid provides valuable input for smartphone users and security service firms seeking to identify misbehaving applications.},
	articleno    = 5,
	numpages     = 29,
	keywords     = {mobile apps, privacy monitoring, smartphones, Information-flow tracking}
}
@inproceedings{10.1145/2627393.2627396,
	title        = {NativeGuard: Protecting Android Applications from Third-Party Native Libraries},
	author       = {Sun, Mengtao and Tan, Gang},
	year         = 2014,
	booktitle    = {Proceedings of the 2014 ACM Conference on Security and Privacy in Wireless \& Mobile Networks},
	location     = {Oxford, United Kingdom},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {WiSec '14},
	pages        = {165–176},
	doi          = {10.1145/2627393.2627396},
	isbn         = 9781450329729,
	url          = {https://doi.org/10.1145/2627393.2627396},
	abstract     = {Android applications often include third-party libraries written in native code. However, current native components are not well managed by Android's security architecture. We present NativeGuard, a security framework that isolates native libraries from other components in Android applications. Leveraging the process-based protection in Android, NativeGuard isolates native libraries of an Android application into a second application where unnecessary privileges are eliminated. NativeGuard requires neither modifications to Android nor access to the source code of an application. It addresses multiple technical issues to support various interfaces that Android provides to the native world. Experimental results demonstrate that our framework works well with a set of real-world applications, and incurs only modest overhead on benchmark programs.},
	numpages     = 12,
	keywords     = {android, privilege isolation, java native interface}
}
@inproceedings{10.1145/2635868.2635869,
	title        = {Apposcopy: Semantics-Based Detection of Android Malware through Static Analysis},
	author       = {Feng, Yu and Anand, Saswat and Dillig, Isil and Aiken, Alex},
	year         = 2014,
	booktitle    = {Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering},
	location     = {Hong Kong, China},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {FSE 2014},
	pages        = {576–587},
	doi          = {10.1145/2635868.2635869},
	isbn         = 9781450330565,
	url          = {https://doi.org/10.1145/2635868.2635869},
	abstract     = {We present Apposcopy, a new semantics-based approach for identifying a prevalent class of Android malware that steals private user information. Apposcopy incorporates (i) a high-level language for specifying signatures that describe semantic characteristics of malware families and (ii) a static analysis for deciding if a given application matches a malware signature. The signature matching algorithm of Apposcopy uses a combination of static taint analysis and a new form of program representation called Inter-Component Call Graph to efficiently detect Android applications that have certain control- and data-flow properties. We have evaluated Apposcopy on a corpus of real-world Android applications and show that it can effectively and reliably pinpoint malicious applications that belong to certain malware families.},
	numpages     = 12,
	keywords     = {Inter-component Call Graph, Android, Taint Analysis}
}
@inproceedings{10.1145/2660267.2660357,
	title        = {Amandroid: A Precise and General Inter-Component Data Flow Analysis Framework for Security Vetting of Android Apps},
	author       = {Wei, Fengguo and Roy, Sankardas and Ou, Xinming and Robby},
	year         = 2014,
	booktitle    = {Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security},
	location     = {Scottsdale, Arizona, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {CCS '14},
	pages        = {1329–1341},
	doi          = {10.1145/2660267.2660357},
	isbn         = 9781450329576,
	url          = {https://doi.org/10.1145/2660267.2660357},
	abstract     = {We propose a new approach to conduct static analysis for security vetting of Android apps, and built a general framework, called Amandroid for determining points-to information for all objects in an Android app in a flow- and context-sensitive way across Android apps components. We show that: (a) this type of comprehensive analysis is completely feasible in terms of computing resources needed with modern hardware, (b) one can easily leverage the results from this general analysis to build various types of specialized security analyses -- in many cases the amount of additional coding needed is around 100 lines of code, and (c) the result of those specialized analyses leveraging Amandroid is at least on par and often exceeds prior works designed for the specific problems, which we demonstrate by comparing Amandroid's results with those of prior works whenever we can obtain the executable of those tools. Since Amandroid's analysis directly handles inter-component control and data flows, it can be used to address security problems that result from interactions among multiple components from either the same or different apps. Amandroid's analysis is sound in that it can provide assurance of the absence of the specified security problems in an app with well-specified and reasonable assumptions on Android runtime system and its library.},
	numpages     = 13,
	keywords     = {points-to analysis, icc (inter-component communication), android application, security vetting, information leakage, vulnerable app, malware}
}
@inproceedings{10.1007/978-3-319-60876-1_12,
	title        = {Deep Ground Truth Analysis of Current Android Malware},
	author       = {Wei, Fengguo and Li, Yuping and Roy, Sankardas and Ou, Xinming and Zhou, Wu},
	year         = 2017,
	booktitle    = {Detection of Intrusions and Malware, and Vulnerability Assessment},
	publisher    = {Springer International Publishing},
	address      = {Cham},
	pages        = {252--276},
	isbn         = {978-3-319-60876-1},
	editor       = {Polychronakis, Michalis and Meier, Michael},
	abstract     = {To build effective malware analysis techniques and to evaluate new detection tools, up-to-date datasets reflecting the current Android malware landscape are essential. For such datasets to be maximally useful, they need to contain reliable and complete information on malware's behaviors and techniques used in the malicious activities. Such a dataset shall also provide a comprehensive coverage of a large number of types of malware. The Android Malware Genome created circa 2011 has been the only well-labeled and widely studied dataset the research community had easy access to (As of 12/21/2015 the Genome authors have stopped supporting the dataset sharing due to resource limitation). But not only is it outdated and no longer represents the current Android malware landscape, it also does not provide as detailed information on malware's behaviors as needed for research. Thus it is urgent to create a high-quality dataset for Android malware. While existing information sources such as VirusTotal are useful, to obtain the accurate and detailed information for malware behaviors, deep manual analysis is indispensable. In this work we present our approach to preparing a large Android malware dataset for the research community. We leverage existing anti-virus scan results and automation techniques in categorizing our large dataset (containing 24,650 malware app samples) into 135 varieties (based on malware behavioral semantics) which belong to 71 malware families. For each variety, we select three samples as representatives, for a total of 405 malware samples, to conduct in-depth manual analysis. Based on the manual analysis result we generate detailed descriptions of each malware variety's behaviors and include them in our dataset. We also report our observations on the current landscape of Android malware as depicted in the dataset. Furthermore, we present detailed documentation of the process used in creating the dataset, including the guidelines for the manual analysis. We make our Android malware dataset available to the research community.}
}
@inproceedings{10.1145/2714576.2714604,
	title        = {Android Implicit Information Flow Demystified},
	author       = {You, Wei and Liang, Bin and Li, Jingzhe and Shi, Wenchang and Zhang, Xiangyu},
	year         = 2015,
	booktitle    = {Proceedings of the 10th ACM Symposium on Information, Computer and Communications Security},
	location     = {Singapore, Republic of Singapore},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ASIA CCS '15},
	pages        = {585–590},
	doi          = {10.1145/2714576.2714604},
	isbn         = 9781450332453,
	url          = {https://doi.org/10.1145/2714576.2714604},
	abstract     = {In this paper, a comprehensive analysis of implicit information flow (IIF) on the Android bytecode is presented to identify all potential IIF forms, determine their exploitability, and mitigate the potential threat. By applying control-transfer-oriented semantic analysis of the bytecode language, we identify five IIF forms, some of which are not studied by existing IIF literature. We develop proof-of-concepts (PoCs) for each IIF form to demonstrate their exploitability. The experimental results show that all these PoCs can effectively and efficiently transmit sensitive data, as well as successfully evade the detection of a state-of-the-art privacy monitor TaintDroid. To mitigate the threat of IIF, we propose a solution to defending against IIF leveraging a special control dependence tracking technique and implement a prototype system. The evaluation shows that the prototype can effectively detect information leak by all the identified IIF forms and also real-world malware with an acceptable overhead. In summary, our study gives in-depth insight into Android IIF from both offensive and defensive perspectives, and provides a foundation for further research on Android IIF.},
	numpages     = 6,
	keywords     = {implicit information flow, android, mitigation, exploitation}
}
@inproceedings{10.1109/ICSE-Companion55297.2022.9793791,
	title        = {ICCBot: Fragment-Aware and Context-Sensitive ICC Resolution for Android Applications},
	author       = {Yan, Jiwei and Zhang, Shixin and Liu, Yepang and Yan, Jun and Zhang, Jian},
	year         = 2022,
	booktitle    = {2022 IEEE/ACM 44th International Conference on Software Engineering: Companion Proceedings (ICSE-Companion)},
	pages        = {105--109},
	doi          = {10.1109/ICSE-Companion55297.2022.9793791}
}
@inbook{10.1145/3368089.3409699,
	title        = {Static Asynchronous Component Misuse Detection for Android Applications},
	author       = {Pan, Linjie and Cui, Baoquan and Liu, Hao and Yan, Jiwei and Wang, Siqi and Yan, Jun and Zhang, Jian},
	year         = 2020,
	booktitle    = {Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	pages        = {952–963},
	isbn         = 9781450370431,
	url          = {https://doi.org/10.1145/3368089.3409699},
	abstract     = {Facing the limited resource of smartphones, asynchronous programming significantly improves the performance of Android applications. Android provides several packaged components to ease the development of asynchronous programming. Among them, the AsyncTask component is widely used by developers since it is easy to implement. However, the abuse of AsyncTask component can decrease responsiveness and even lead to crashes. By investigating the Android Developer Documentation and technical forums, we summarize five misuse patterns about AsyncTask. To detect them, we propose a flow, context, object and field-sensitive inter-procedural static analysis approach. Specifically, the static analysis includes typestate analysis, reference analysis and loop analysis. Based on the AsyncTask-related information obtained during static analysis, we check the misuse according to predefined detection rules. The proposed approach is implemented into a tool called AsyncChecker. We evaluate AsyncChecker on a self-designed benchmark suite called AsyncBench and 1,759 real-world apps. AsyncChecker finds 17,946 misused AsyncTask instances in 1,417 real-world apps (80.6\%). The precision, recall and F-measure of AsyncChecker on real-world applications are 97.2\%, 89.8\% and 0.93, respectively. Compared with existing tools, AsyncChecker can detect more asynchronous problems. We report the misuse problems to developers via GitHub. Several developers have confirmed and fixed the problems found by AsyncChecker. The result implies that our approach is effective and developers do take the misuse of AsyncTask as a serious problem.},
	numpages     = 12
}
@inproceedings{BarrosJMVDdAE2015,
	title        = {Static analysis of implicit control flow: Resolving {Java} reflection and {Android} intents},
	author       = {Paulo Barros and Ren{\'e} Just and Suzanne Millstein and Paul Vines and Werner Dietl and Marcelo d'Amorim and Michael D. Ernst},
	year         = 2015,
	month        = {November~11--13},
	booktitle    = {Proceedings of the International Conference on Automated Software Engineering (ASE)},
	address      = {Lincoln, NE, USA},
	pages        = {669--679}
}
@article{10.1145/2666356.2594299,
	title        = {FlowDroid: Precise Context, Flow, Field, Object-Sensitive and Lifecycle-Aware Taint Analysis for Android Apps},
	author       = {Arzt, Steven and Rasthofer, Siegfried and Fritz, Christian and Bodden, Eric and Bartel, Alexandre and Klein, Jacques and Le Traon, Yves and Octeau, Damien and McDaniel, Patrick},
	year         = 2014,
	month        = jun,
	journal      = {ACM SIGPLAN NOTICES},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 49,
	number       = 6,
	pages        = {259–269},
	doi          = {10.1145/2666356.2594299},
	issn         = {0362-1340},
	url          = {https://doi.org/10.1145/2666356.2594299},
	issue_date   = {June 2014},
	numpages     = 11
}
@article{10.1145/2666356.2594311,
	title        = {Race Detection for Android Applications},
	author       = {Maiya, Pallavi and Kanade, Aditya and Majumdar, Rupak},
	year         = 2014,
	month        = jun,
	journal      = {ACM SIGPLAN NOTICES},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 49,
	number       = 6,
	pages        = {316–325},
	doi          = {10.1145/2666356.2594311},
	issn         = {0362-1340},
	url          = {https://doi.org/10.1145/2666356.2594311},
	issue_date   = {June 2014},
	abstract     = {Programming environments for smartphones expose a concurrency model that combines multi-threading and asynchronous event-based dispatch. While this enables the development of efficient and feature-rich applications, unforeseen thread interleavings coupled with non-deterministic reorderings of asynchronous tasks can lead to subtle concurrency errors in the applications.In this paper, we formalize the concurrency semantics of the Android programming model. We further define the happens-before relation for Android applications, and develop a dynamic race detection technique based on this relation. Our relation generalizes the so far independently studied happens-before relations for multi-threaded programs and single-threaded event-driven programs. Additionally, our race detection technique uses a model of the Android runtime environment to reduce false positives.We have implemented a tool called DroidRacer. It generates execution traces by systematically testing Android applications and detects data races by computing the happens-before relation on the traces. We analyzed 15 Android applications including popular applications such as Facebook, Twitter and K-9 Mail. Our results indicate that data races are prevalent in Android applications, and that DroidRacer is an effective tool to identify data races.},
	numpages     = 10,
	keywords     = {happens-before reasoning, data races, Android concurrency semantics}
}
@article{10.1145/279310.279314,
	title        = {An Empirical Study of Static Call Graph Extractors},
	author       = {Murphy, Gail C. and Notkin, David and Griswold, William G. and Lan, Erica S.},
	year         = 1998,
	month        = apr,
	journal      = {ACM Transactions on Software Engineering and Methodology},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 7,
	number       = 2,
	pages        = {158–191},
	doi          = {10.1145/279310.279314},
	issn         = {1049-331X},
	url          = {https://doi.org/10.1145/279310.279314},
	issue_date   = {April 1998},
	abstract     = {Informally, a call graph represents calls between entities in a given program. The call graphs that compilers compute to determine the applicability of an optimization must typically be conservative: a call may be omitted only if it can never occur in any execution of the program. Numerous software engineering tools also extract call graphs with the expectation that they will help software engineers increase their understanding of a program. The requirements placed on software engineering tools that compute call graphs are typically more relaxed than for compilers. For example, some false negatives—calls that can in fact take place in some execution of the program, but which are omitted from the call graph—may be acceptable, depending on the understanding task at hand. In  this article, we empirically show a consequence of this spectrum of requirements by comparing the C call graphs extracted from three software systems (mapmaker, mosaic, and gcc) by nine tools (cflow, cawk, CIA, Field, GCT, Imagix, LSME, Mawk, and Rigiparse). A quantitative analysis of the call graphs extracted for each system shows considerable variation, a result that is counterintuitive to many experienced software engineers. A qualitative analysis of these results reveals a number of reasons for  this variation: differing treatments of macros, function pointers, input formats, etc. The fundamental problem is not that variances among the graphs extracted by different tools exist, but that software engineers have little sense of the dimensions of approximation in any particular call  graph. In this article, we describe and discuss the study, sketch a design space for static call graph extractors, and discuss the impact of our study on practitioners, tool developers, and researchers. Although this article considers only one kind of information, call graphs, many of the observations also apply to static extractors of other kinds of information, such as inheritance structures, file dependences, and references to global variables.},
	numpages     = 34,
	keywords     = {design space, empirical study, software system analysis, static analysis, call graphs}
}
@article{10.1145/286942.286945,
	title        = {Dynamic Class Loading in the Java Virtual Machine},
	author       = {Liang, Sheng and Bracha, Gilad},
	year         = 1998,
	month        = oct,
	journal      = {ACM SIGPLAN NOTICES},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 33,
	number       = 10,
	pages        = {36–44},
	doi          = {10.1145/286942.286945},
	issn         = {0362-1340},
	url          = {https://doi.org/10.1145/286942.286945},
	issue_date   = {Oct. 1998},
	abstract     = {Class loaders are a powerful mechanism for dynamically loading software components on the Java platform. They are unusual in supporting all of the following features: laziness, type-safe linkage, user-defined extensibility, and multiple communicating namespaces.We present the notion of class loaders and demonstrate some of their interesting uses. In addition, we discuss how to maintain type safety in the presence of user-defined dynamic class loading.},
	numpages     = 9
}
@inproceedings{10.1145/2892208.2892218,
	title        = {Static Detection of Energy Defect Patterns in Android Applications},
	author       = {Wu, Haowei and Yang, Shengqian and Rountev, Atanas},
	year         = 2016,
	booktitle    = {Proceedings of the 25th International Conference on Compiler Construction},
	location     = {Barcelona, Spain},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {CC 2016},
	pages        = {185–195},
	doi          = {10.1145/2892208.2892218},
	isbn         = 9781450342414,
	url          = {https://doi.org/10.1145/2892208.2892218},
	abstract     = {For static analysis researchers, Android software presents a wide variety of interesting challenges. The target of our work is static detection of energy-drain defects in Android applications. The management of energy-intensive resources (e.g., GPS) creates various opportunities for software defects. Our goal is to detect statically “missing deactivation” energy-drain defects in the user interface of the application. First, we define precisely two patterns of run-time energy-drain behaviors, based on modeling of Android GUI control-flow paths and energy-related listener leaks along such paths. Next, we define a static detection algorithm targeting these patterns. The analysis considers valid interprocedural control-flow paths in a callback method and its transitive callees, in order to detect operations that add or remove listeners. Sequences of callbacks are then analyzed for possible listener leaks. Our evaluation considers the detection of GUI-related energy-drain defects reported in prior work, as well as new defects not discovered by prior approaches. In summary, the detection is very effective and precise, suggesting that the proposed analysis is suitable for practical use in static checking tools for Android.},
	numpages     = 11,
	keywords     = {energy, GUI analysis, static analysis, Android}
}
@inproceedings{10.1145/2896921.2896932,
	title        = {Automated Test Generation for Detection of Leaks in Android Applications},
	author       = {Zhang, Hailong and Wu, Haowei and Rountev, Atanas},
	year         = 2016,
	booktitle    = {Proceedings of the 11th International Workshop on Automation of Software Test},
	location     = {Austin, Texas},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {AST '16},
	pages        = {64–70},
	doi          = {10.1145/2896921.2896932},
	isbn         = 9781450341516,
	url          = {https://doi.org/10.1145/2896921.2896932},
	abstract     = {Android devices have limited hardware resources (e.g., memory). Excessive consumption of such resources may lead to crashes, poor responsiveness, battery drain, and negative user experience. We propose an approach for systematic automated test generation to expose resource leak defects in Android applications. We first define the notion of a neutral sequence of GUI events. Intuitively, such a sequence can be expected to have "neutral" effects on resource consumption, and repeated executions of this sequence should not exhibit resource growth. Using a state-of-the-art static control-flow model of an Android application, we demonstrate how to achieve automated generation of such sequences. We then define test generation algorithms for two important categories of neutral sequences, based on common leak patterns specific to Android. Our experimental evaluation compares this approach with a non-automated approach from prior work. The results from this evaluation strongly indicate that it is possible to achieve effective, general, and automated test generation for resource leaks in Android applications using the proposed techniques.},
	numpages     = 7
}
@inproceedings{10.1145/2901739.2903508,
	title        = {AndroZoo: Collecting Millions of Android Apps for the Research Community},
	author       = {Allix, Kevin and Bissyand{\'e}, Tegawend{\'e} F. and Klein, Jacques and Le Traon, Yves},
	year         = 2016,
	booktitle    = {Proceedings of the 13th International Conference on Mining Software Repositories},
	location     = {Austin, Texas},
	publisher    = {ACM},
	address      = {New York, NY, USA},
	series       = {MSR '16},
	pages        = {468--471},
	doi          = {10.1145/2901739.2903508},
	isbn         = {978-1-4503-4186-8},
	url          = {http://doi.acm.org/10.1145/2901739.2903508},
	numpages     = 4,
	acmid        = 2903508,
	keywords     = {APK, android applications, software repository}
}
@inproceedings{10.1145/2931037.2931044,
	title        = {DroidRA: Taming Reflection to Support Whole-Program Analysis of Android Apps},
	author       = {Li, Li and Bissyand\'{e}, Tegawend\'{e} F. and Octeau, Damien and Klein, Jacques},
	year         = 2016,
	booktitle    = {Proceedings of the 25th International Symposium on Software Testing and Analysis},
	location     = {Saarbr\"{u}cken, Germany},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ISSTA 2016},
	pages        = {318–329},
	doi          = {10.1145/2931037.2931044},
	isbn         = 9781450343909,
	url          = {https://doi.org/10.1145/2931037.2931044},
	abstract     = {Android developers heavily use reflection in their apps for legitimate reasons, but also significantly for hiding malicious actions. Unfortunately, current state-of-the-art static analysis tools for Android are challenged by the presence of reflective calls which they usually ignore. Thus, the results of their security analysis, e.g., for private data leaks, are inconsistent given the measures taken by malware writers to elude static detection. We propose the DroidRA instrumentation-based approach to address this issue in a non-invasive way. With DroidRA, we reduce the resolution of reflective calls to a composite constant propagation problem. We leverage the COAL solver to infer the values of reflection targets and app, and we eventually instrument this app to include the corresponding traditional Java call for each reflective call. Our approach allows to boost an app so that it can be immediately analyzable, including by such static analyzers that were not reflection-aware. We evaluate DroidRA on benchmark apps as well as on real-world apps, and demonstrate that it can allow state-of-the-art tools to provide more sound and complete analysis results.},
	numpages     = 12,
	keywords     = {Android, Reflection, DroidRA, Static Analysis}
}
@article{van2013dynamic,
	title        = {Dynamic analysis of android malware},
	author       = {Van Der Veen, Victor and Bos, Herbert and Rossow, Christian},
	year         = 2013,
	journal      = {Internet \& Web Technology Master thesis, VU University Amsterdam}
}
@inproceedings{10.1145/2660267.2660343,
	title        = {Collaborative Verification of Information Flow for a High-Assurance App Store},
	author       = {Ernst, Michael D. and Just, Ren\'{e} and Millstein, Suzanne and Dietl, Werner and Pernsteiner, Stuart and Roesner, Franziska and Koscher, Karl and Barros, Paulo Barros and Bhoraskar, Ravi and Han, Seungyeop and Vines, Paul and Wu, Edward X.},
	year         = 2014,
	booktitle    = {Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security},
	location     = {Scottsdale, Arizona, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {CCS '14},
	pages        = {1092–1104},
	doi          = {10.1145/2660267.2660343},
	isbn         = 9781450329576,
	url          = {https://doi.org/10.1145/2660267.2660343},
	abstract     = {Current app stores distribute some malware to unsuspecting users, even though the app approval process may be costly and time-consuming. High-integrity app stores must provide stronger guarantees that their apps are not malicious. We propose a verification model for use in such app stores to guarantee that the apps are free of malicious information flows. In our model, the software vendor and the app store auditor collaborate -- each does tasks that are easy for her/him, reducing overall verification cost. The software vendor provides a behavioral specification of information flow (at a finer granularity than used by current app stores) and source code annotated with information-flow type qualifiers. A flow-sensitive, context-sensitive information-flow type system checks the information flow type qualifiers in the source code and proves that only information flows in the specification can occur at run time. The app store auditor uses the vendor-provided source code to manually verify declassifications.We have implemented the information-flow type system for Android apps written in Java, and we evaluated both its effectiveness at detecting information-flow violations and its usability in practice. In an adversarial Red Team evaluation, we analyzed 72 apps (576,000 LOC) for malware. The 57 Trojans among these had been written specifically to defeat a malware analysis such as ours. Nonetheless, our information-flow type system was effective: it detected 96\% of malware whose malicious behavior was related to information flow and 82\% of all malware. In addition to the adversarial evaluation, we evaluated the practicality of using the collaborative model. The programmer annotation burden is low: 6 annotations per 100 LOC. Every sound analysis requires a human to review potential false alarms, and in our experiments, this took 30 minutes per 1,000 LOC for an auditor unfamiliar with the app.},
	numpages     = 13,
	keywords     = {static analysis, android security, information flow, collaborative verification}
}
@inproceedings{10.1145/2931037.2931054,
	title        = {Sapienz: Multi-Objective Automated Testing for Android Applications},
	author       = {Mao, Ke and Harman, Mark and Jia, Yue},
	year         = 2016,
	booktitle    = {Proceedings of the 25th International Symposium on Software Testing and Analysis},
	location     = {Saarbr\"{u}cken, Germany},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ISSTA 2016},
	pages        = {94–105},
	doi          = {10.1145/2931037.2931054},
	isbn         = 9781450343909,
	url          = {https://doi.org/10.1145/2931037.2931054},
	abstract     = {We introduce Sapienz, an approach to Android testing that uses multi-objective search-based testing to automatically explore and optimise test sequences, minimising length, while simultaneously maximising coverage and fault revelation. Sapienz combines random fuzzing, systematic and search-based exploration, exploiting seeding and multi-level instrumentation. Sapienz significantly outperforms (with large effect size) both the state-of-the-art technique Dynodroid and the widely-used tool, Android Monkey, in 7/10 experiments for coverage, 7/10 for fault detection and 10/10 for fault-revealing sequence length. When applied to the top 1,000 Google Play apps, Sapienz found 558 unique, previously unknown crashes. So far we have managed to make contact with the developers of 27 crashing apps. Of these, 14 have confirmed that the crashes are caused by real faults. Of those 14, six already have developer-confirmed fixes.},
	numpages     = 12,
	keywords     = {Test generation, Search-based software testing, Android}
}
@inproceedings{10.1145/2976749.2978343,
	title        = {TaintART: A Practical Multi-Level Information-Flow Tracking System for Android RunTime},
	author       = {Sun, Mingshen and Wei, Tao and Lui, John C.S.},
	year         = 2016,
	booktitle    = {Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security},
	location     = {Vienna, Austria},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {CCS '16},
	pages        = {331–342},
	doi          = {10.1145/2976749.2978343},
	isbn         = 9781450341394,
	url          = {https://doi.org/10.1145/2976749.2978343},
	abstract     = {Mobile operating systems like Android failed to provide sufficient protection on personal data, and privacy leakage becomes a major concern. To understand the security risks and privacy leakage, analysts have to carry out data-flow analysis. In 2014, Android upgraded with a fundamentally new design known as Android RunTime (ART) environment in Android 5.0. ART adopts ahead-of-time compilation strategy and replaces previous virtual-machine-based Dalvik. Unfortunately, many data-flow analysis systems like TaintDroid were designed for the legacy Dalvik environment. This makes data-flow analysis of new apps and malware infeasible. We design a multi-level information-flow tracking system for the new Android system called TaintART. TaintART employs a multi-level taint analysis technique to minimize the taint tag storage. Therefore, taint tags can be stored in processor registers to provide efficient taint propagation operations. We also customize the ART compiler to maximize performance gains of the ahead-of-time compilation optimizations. Based on the general design of TaintART, we also implement a multi-level privacy enforcement to prevent sensitive data leakage. We demonstrate that TaintART only incurs less than 15\% overheads on a CPU-bound microbenchmark and negligible overhead on built-in or third-party applications. Compared to legacy Dalvik environment in Android 4.4, TaintART achieves about 99.7\% faster performance for Java runtime benchmark.},
	numpages     = 12,
	keywords     = {information-flow tracking, android runtime, taintart, taint analysis, android}
}
@inproceedings{10.1145/3021460.3021485,
	title        = {Dynamic Permissions Based Android Malware Detection Using Machine Learning Techniques},
	author       = {Mahindru, Arvind and Singh, Paramvir},
	year         = 2017,
	booktitle    = {Proceedings of the 10th Innovations in Software Engineering Conference},
	location     = {Jaipur, India},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ISEC '17},
	pages        = {202–210},
	doi          = {10.1145/3021460.3021485},
	isbn         = 9781450348560,
	url          = {https://doi.org/10.1145/3021460.3021485},
	abstract     = {Android is by far the most widely used mobile phone operating system around. However, Android based applications are highly vulnerable to various types of malware attacks attributed to their open nature and high popularity in the market. The fault lies in the underneath permission model of Android applications. These applications need a number of sensitive permissions during their installation and runtime, which enables possible security breaches by malware. The contributions of this paper are twofold: 1) We extract a set of 123 dynamic permissions from 11000 Android applications in a largest publicly available dataset till date; 2) We evaluate a number of machine learning classification techniques including Naive Bayes (NB), Decision Tree (J48), Random Forest (RF), Simple Logistic (SL), and k-star on the newly designed dataset for detecting malicious Android applications. The experimental results indicate that although the malware classification accuracy of RF, J48, and SL are comparable, SL performs marginally better than the other techniques.},
	numpages     = 9,
	keywords     = {Machine Learning, Android, Malware Detection, Dynamic Analysis}
}
@inproceedings{10.1145/3029806.3029823,
	title        = {Deep Android Malware Detection},
	author       = {McLaughlin, Niall and Martinez del Rincon, Jesus and Kang, BooJoong and Yerima, Suleiman and Miller, Paul and Sezer, Sakir and Safaei, Yeganeh and Trickel, Erik and Zhao, Ziming and Doup\'{e}, Adam and Joon Ahn, Gail},
	year         = 2017,
	booktitle    = {Proceedings of the Seventh ACM on Conference on Data and Application Security and Privacy},
	location     = {Scottsdale, Arizona, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {CODASPY '17},
	pages        = {301–308},
	doi          = {10.1145/3029806.3029823},
	isbn         = 9781450345231,
	url          = {https://doi.org/10.1145/3029806.3029823},
	abstract     = {In this paper, we propose a novel android malware detection system that uses a deep convolutional neural network (CNN). Malware classification is performed based on static analysis of the raw opcode sequence from a disassembled program. Features indicative of malware are automatically learned by the network from the raw opcode sequence thus removing the need for hand-engineered malware features. The training pipeline of our proposed system is much simpler than existing n-gram based malware detection methods, as the network is trained end-to-end to jointly learn appropriate features and to perform classification, thus removing the need to explicitly enumerate millions of n-grams during training. The network design also allows the use of long n-gram like features, not computationally feasible with existing methods. Once trained, the network can be efficiently executed on a GPU, allowing a very large number of files to be scanned quickly.},
	numpages     = 8,
	keywords     = {deep learning, malware detection, android}
}
@inproceedings{10.1145/3098954.3105821,
	title        = {Towards Semi-Automated Detection of Trigger-Based Behavior for Software Security Assurance},
	author       = {Papp, Dorottya and Butty\'{a}n, Levente and Ma, Zhendong},
	year         = 2017,
	booktitle    = {Proceedings of the 12th International Conference on Availability, Reliability and Security},
	location     = {Reggio Calabria, Italy},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ARES '17},
	doi          = {10.1145/3098954.3105821},
	isbn         = 9781450352574,
	url          = {https://doi.org/10.1145/3098954.3105821},
	abstract     = {A program exhibits trigger-based behavior if it performs undocumented, often malicious, functions when the environmental conditions and/or specific input values match some pre-specified criteria. Checking whether such hidden functions exist in the program is important for increasing trustworthiness of software. In this paper, we propose a framework to effectively detect trigger-based behavior at the source code level. Our approach is semi-automated: We use automated source code instrumentation and mixed concrete and symbolic execution to generate potentially suspicious test cases that may trigger hidden, potentially malicious functions. The test cases must be investigated by a human analyst manually to decide which of them are real triggers. While our approach is not fully automated, it greatly reduces manual work by allowing analysts to focus on a few test cases found by our automated tools.},
	articleno    = 64,
	numpages     = 6,
	keywords     = {Trigger-based Behavior, Software Security, Mixed Concrete and Symbolic Execution, Static Analysis, Source Code Analysis}
}
@inproceedings{10.1145/3106237.3106286,
	title        = {Automatic Generation of Inter-Component Communication Exploits for Android Applications},
	author       = {Garcia, Joshua and Hammad, Mahmoud and Ghorbani, Negar and Malek, Sam},
	year         = 2017,
	booktitle    = {Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering},
	location     = {Paderborn, Germany},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ESEC/FSE 2017},
	pages        = {661–671},
	doi          = {10.1145/3106237.3106286},
	isbn         = 9781450351058,
	url          = {https://doi.org/10.1145/3106237.3106286},
	abstract     = {Although a wide variety of approaches identify vulnerabilities in Android apps, none attempt to determine exploitability of those vulnerabilities. Exploitability can aid in reducing false positives of vulnerability analysis, and can help engineers triage bugs. Specifically, one of the main attack vectors of Android apps is their inter-component communication interface, where apps may receive messages called Intents. In this paper, we provide the first approach for automatically generating exploits for Android apps, called LetterBomb, relying on a combined path-sensitive symbolic execution-based static analysis, and the use of software instrumentation and test oracles. We run LetterBomb on 10,000 Android apps from Google Play, where we identify 181 exploits from 835 vulnerable apps. Compared to a state-of-the-art detection approach for three ICC-based vulnerabilities, LetterBomb obtains 33%-60% more vulnerabilities at a 6.66 to 7 times faster speed.},
	numpages     = 11,
	keywords     = {vulnerability, test oracle, test generation, exploit, Android}
}
@inproceedings{10.1145/3106237.3106298,
	title        = {Guided, Stochastic Model-Based GUI Testing of Android Apps},
	author       = {Su, Ting and Meng, Guozhu and Chen, Yuting and Wu, Ke and Yang, Weiming and Yao, Yao and Pu, Geguang and Liu, Yang and Su, Zhendong},
	year         = 2017,
	booktitle    = {Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering},
	location     = {Paderborn, Germany},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ESEC/FSE 2017},
	pages        = {245–256},
	doi          = {10.1145/3106237.3106298},
	isbn         = 9781450351058,
	url          = {https://doi.org/10.1145/3106237.3106298},
	abstract     = {Mobile apps are ubiquitous, operate in complex environments and are developed under the time-to-market pressure. Ensuring their correctness and reliability thus becomes an important challenge. This paper introduces Stoat, a novel guided approach to perform stochastic model-based testing on Android apps. Stoat operates in two phases: (1) Given an app as input, it uses dynamic analysis enhanced by a weighted UI exploration strategy and static analysis to reverse engineer a stochastic model of the app's GUI interactions; and (2) it adapts Gibbs sampling to iteratively mutate/refine the stochastic model and guides test generation from the mutated models toward achieving high code and model coverage and exhibiting diverse sequences. During testing, system-level events are randomly injected to further enhance the testing effectiveness. Stoat was evaluated on 93 open-source apps. The results show (1) the models produced by Stoat cover 17~31\% more code than those by existing modeling tools; (2) Stoat detects 3X more unique crashes than two state-of-the-art testing tools, Monkey and Sapienz. Furthermore, Stoat tested 1661 most popular Google Play apps, and detected 2110 previously unknown and unique crashes. So far, 43 developers have responded that they are investigating our reports. 20 of reported crashes have been confirmed, and 8 already fixed.},
	numpages     = 12,
	keywords     = {Model-based Testing, GUI Testing, Mobile Apps}
}
@inproceedings{10.1145/3180155.3180228,
	title        = {A Large-Scale Empirical Study on the Effects of Code Obfuscations on Android Apps and Anti-Malware Products},
	author       = {Hammad, Mahmoud and Garcia, Joshua and Malek, Sam},
	year         = 2018,
	booktitle    = {Proceedings of the 40th International Conference on Software Engineering},
	location     = {Gothenburg, Sweden},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ICSE '18},
	pages        = {421–431},
	doi          = {10.1145/3180155.3180228},
	isbn         = 9781450356381,
	url          = {https://doi.org/10.1145/3180155.3180228},
	abstract     = {The Android platform has been the dominant mobile platform in recent years resulting in millions of apps and security threats against those apps. Anti-malware products aim to protect smartphone users from these threats, especially from malicious apps. However, malware authors use code obfuscation on their apps to evade detection by anti-malware products. To assess the effects of code obfuscation on Android apps and anti-malware products, we have conducted a large-scale empirical study that evaluates the effectiveness of the top anti-malware products against various obfuscation tools and strategies. To that end, we have obfuscated 3,000 benign apps and 3,000 malicious apps and generated 73,362 obfuscated apps using 29 obfuscation strategies from 7 open-source, academic, and commercial obfuscation tools. The findings of our study indicate that (1) code obfuscation significantly impacts Android anti-malware products; (2) the majority of anti-malware products are severely impacted by even trivial obfuscations; (3) in general, combined obfuscation strategies do not successfully evade anti-malware products more than individual strategies; (4) the detection of anti-malware products depend not only on the applied obfuscation strategy but also on the leveraged obfuscation tool; (5) anti-malware products are slow to adopt signatures of malicious apps; and (6) code obfuscation often results in changes to an app's semantic behaviors.},
	numpages     = 11
}
@inproceedings{10.1145/3180155.3180243,
	title        = {Repairing Crashes in Android Apps},
	author       = {Tan, Shin Hwei and Dong, Zhen and Gao, Xiang and Roychoudhury, Abhik},
	year         = 2018,
	booktitle    = {Proceedings of the 40th International Conference on Software Engineering},
	location     = {Gothenburg, Sweden},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ICSE '18},
	pages        = {187–198},
	doi          = {10.1145/3180155.3180243},
	isbn         = 9781450356381,
	url          = {https://doi.org/10.1145/3180155.3180243},
	abstract     = {Android apps are omnipresent, and frequently suffer from crashes --- leading to poor user experience and economic loss. Past work focused on automated test generation to detect crashes in Android apps. However, automated repair of crashes has not been studied. In this paper, we propose the first approach to automatically repair Android apps, specifically we propose a technique for fixing crashes in Android apps. Unlike most test-based repair approaches, we do not need a test-suite; instead a single failing test is meticulously analyzed for crash locations and reasons behind these crashes. Our approach hinges on a careful empirical study which seeks to establish common root-causes for crashes in Android apps, and then distills the remedy of these root-causes in the form of eight generic transformation operators. These operators are applied using a search-based repair framework embodied in our repair tool Droix. We also prepare a benchmark DroixBench capturing reproducible crashes in Android apps. Our evaluation of Droix on DroixBench reveals that the automatically produced patches are often syntactically identical to the human patch, and on some rare occasion even better than the human patch (in terms of avoiding regressions). These results confirm our intuition that our proposed transformations form a sufficient set of operators to patch crashes in Android.},
	numpages     = 12,
	keywords     = {crash, automated repair, SBSE, Android apps}
}
@inproceedings{10.1145/3197231.3197239,
	title        = {ARES: Triggering Payload of Evasive Android Malware},
	author       = {Bello, Luciano and Pistoia, Marco},
	year         = 2018,
	booktitle    = {Proceedings of the 5th International Conference on Mobile Software Engineering and Systems},
	location     = {Gothenburg, Sweden},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {MOBILESoft '18},
	pages        = {2–12},
	doi          = {10.1145/3197231.3197239},
	isbn         = 9781450357128,
	url          = {https://doi.org/10.1145/3197231.3197239},
	abstract     = {With the emergence of mobile application markets, there has been a dramatic increase in mobile malware. Mobile platform providers are constantly creating and refining their malware-detection techniques, including static analysis and behavioral monitoring. The goal of malware writers is to hide the malware payload from those analyzers. In parallel, security analysts want to quickly detect if any software is malware in order to prevent harm to users. This confrontation is pushing malware writers to develop new evasion techniques that prevent their malware from being detected or making analysis harder.This paper describes ARES, a system built on top of an existing behavioral analysis, based on static information-flow analysis, binary instrumentation, and multiexecution analysis, to detect and bypass many common evasive techniques used by mobile malware. Additionally, this paper presents our implementation of ARES, and shows that, when run against real-world software, ARES is able to reveal previously unknown malicious components. We also developed a test suite for evasion detection techniques: EVADROID, which we have made fully available to other researchers.},
	numpages     = 11
}
@inproceedings{10.1145/3238147.3238207,
	title        = {Self-Protection of Android Systems from Inter-Component Communication Attacks},
	author       = {Hammad, Mahmoud and Garcia, Joshua and Malek, Sam},
	year         = 2018,
	booktitle    = {Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering},
	location     = {Montpellier, France},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ASE 2018},
	pages        = {726–737},
	doi          = {10.1145/3238147.3238207},
	isbn         = 9781450359375,
	url          = {https://doi.org/10.1145/3238147.3238207},
	abstract     = {The current security mechanisms for Android apps, both static and dynamic analysis approaches, are insufficient for detection and prevention of the increasingly dynamic and sophisticated security attacks. Static analysis approaches suffer from false positives whereas dynamic analysis approaches suffer from false negatives. Moreover, they all lack the ability to efficiently analyze systems with incremental changes—such as adding/removing apps, granting/revoking permissions, and dynamic components’ communications. Each time the system changes, the entire analysis needs to be repeated, making the existing approaches inefficient for practical use. To mitigate their shortcomings, we have developed SALMA, a novel self-protecting Android software system that monitors itself and adapts its behavior at runtime to prevent a wide-range of security risks. SALMA maintains a precise architectural model, represented as a Multiple-Domain-Matrix, and incrementally and efficiently analyzes an Android system in response to incremental system changes. The maintained architecture is used to reason about the running Android system. Every time the system changes, SALMA determines (1) the impacted part of the system, and (2) the subset of the security analyses that need to be performed, thereby greatly improving the performance of the approach. Our experimental results on hundreds of real-world apps corroborate SALMA’s scalability and efficiency as well as its ability to detect and prevent security attacks at runtime with minimal disruption.},
	numpages     = 12,
	keywords     = {Self-protecting system, Software Engineering, Android security}
}
@inproceedings{10.1145/3243734.3243835,
	title        = {JN-SAF: Precise and Efficient NDK/JNI-Aware Inter-Language Static Analysis Framework for Security Vetting of Android Applications with Native Code},
	author       = {Wei, Fengguo and Lin, Xingwei and Ou, Xinming and Chen, Ting and Zhang, Xiaosong},
	year         = 2018,
	booktitle    = {Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security},
	location     = {Toronto, Canada},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {CCS '18},
	pages        = {1137–1150},
	doi          = {10.1145/3243734.3243835},
	isbn         = 9781450356930,
	url          = {https://doi.org/10.1145/3243734.3243835},
	abstract     = {Android allows application developers to use native language (C/C++) to implement a part or the complete program. Recent research and our own statistics show that native payloads are commonly used in both benign and malicious apps. Current state-of-the-art Android static analysis tools, such as Amandroid, FlowDroid, DroidSafe, IccTA, and CHEX avoid handling native method invocation and apply conservative models for their data-flow behavior. None of those tools have capability to capture the inter-language dataflow. We propose a new approach to conduct inter-language dataflow analysis for security vetting of Android apps, and build an analysis framework, called JN-SAF to compute flow and context-sensitive inter-language points-to information in an efficient way. We show that: 1) Precise and efficient inter-language dataflow analysis is completely feasible with support of a summary-based bottom-up dataflow analysis (SBDA) algorithm, 2) A comprehensive model of Java Native Interface (JNI) and Native Development Kit (NDK) for binary analysis is essential as none of the existing binary analysis frameworks is able to handle Android binaries, 3) JN-SAF is capable of capturing inter-language security issues in real-world Android apps as demonstrated by our evaluation result.},
	numpages     = 14,
	keywords     = {mobile security, static analysis}
}
@inbook{10.1145/3293882.3330572,
	title        = {Mining Android Crash Fixes in the Absence of Issue- and Change-Tracking Systems},
	author       = {Kong, Pingfan and Li, Li and Gao, Jun and Bissyand\'{e}, Tegawend\'{e} F. and Klein, Jacques},
	year         = 2019,
	booktitle    = {Proceedings of the 28th ACM SIGSOFT International Symposium on Software Testing and Analysis},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	pages        = {78–89},
	isbn         = 9781450362245,
	url          = {https://doi.org/10.1145/3293882.3330572},
	abstract     = {Android apps are prone to crash. This often arises from the misuse of Android framework APIs, making it harder to debug since official Android documentation does not discuss thoroughly potential exceptions.Recently, the program repair community has also started to investigate the possibility to fix crashes automatically. Current results, however, apply to limited example cases. In both scenarios of repair, the main issue is the need for more example data to drive the fix processes due to the high cost in time and effort needed to collect and identify fix examples. We propose in this work a scalable approach, CraftDroid, to mine crash fixes by leveraging a set of 28 thousand carefully reconstructed app lineages from app markets, without the need for the app source code or issue reports. We developed a replicative testing approach that locates fixes among app versions which output different runtime logs with the exact same test inputs. Overall, we have mined 104 relevant crash fixes, further abstracted 17 fine-grained fix templates that are demonstrated to be effective for patching crashed apks. Finally, we release ReCBench, a benchmark consisting of 200 crashed apks and the crash replication scripts, which the community can explore for evaluating generated crash-inducing bug patches.},
	numpages     = 12
}
@inproceedings{10.1145/3324884.3416558,
	title        = {Broadening Horizons of Multilingual Static Analysis: Semantic Summary Extraction from C Code for JNI Program Analysis},
	author       = {Lee, Sungho and Lee, Hyogun and Ryu, Sukyoung},
	year         = 2020,
	booktitle    = {Proceedings of the 35th IEEE/ACM International Conference on Automated Software Engineering},
	location     = {Virtual Event, Australia},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ASE '20},
	pages        = {127–137},
	doi          = {10.1145/3324884.3416558},
	isbn         = 9781450367684,
	url          = {https://doi.org/10.1145/3324884.3416558},
	abstract     = {Most programming languages support foreign language interoperation that allows developers to integrate multiple modules implemented in different languages into a single multilingual program. While utilizing various features from multiple languages expands expressivity, differences in language semantics require developers to understand the semantics of multiple languages and their inter-operation. Because current compilers do not support compile-time checking for interoperation, they do not help developers avoid interoperation bugs. Similarly, active research on static analysis and bug detection has been focusing on programs written in a single language.In this paper, we propose a novel approach to analyze multilingual programs statically. Unlike existing approaches that extend a static analyzer for a host language to support analysis of foreign function calls, our approach extracts semantic summaries from programs written in guest languages using a modular analysis technique, and performs a whole-program analysis with the extracted semantic summaries. To show practicality of our approach, we design and implement a static analyzer for multilingual programs, which analyzes JNI interoperation between Java and C. Our empirical evaluation shows that the analyzer is scalable in that it can construct call graphs for large programs that use JNI interoperation, and useful in that it found 74 genuine interoperation bugs in real-world Android JNI applications.},
	numpages     = 11,
	keywords     = {Java native interface, language interoperability, multilingual program analysis}
}
@inproceedings{10.1145/3395363.3397368,
	title        = {Identifying Java Calls in Native Code via Binary Scanning},
	author       = {Fourtounis, George and Triantafyllou, Leonidas and Smaragdakis, Yannis},
	year         = 2020,
	booktitle    = {Proceedings of the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis},
	location     = {Virtual Event, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ISSTA 2020},
	pages        = {388–400},
	doi          = {10.1145/3395363.3397368},
	isbn         = 9781450380089,
	url          = {https://doi.org/10.1145/3395363.3397368},
	abstract     = {Current Java static analyzers, operating either on the source or bytecode level, exhibit unsoundness for programs that contain native code. We show that the Java Native Interface (JNI) specification, which is used by Java programs to interoperate with Java code, is principled enough to permit static reasoning about the effects of native code on program execution when it comes to call-backs. Our approach consists of disassembling native binaries, recovering static symbol information that corresponds to Java method signatures, and producing a model for statically exercising these native call-backs with appropriate mock objects. The approach manages to recover virtually all Java calls in native code, for both Android and Java desktop applications—(a) achieving 100\% native-to-application call-graph recall on large Android applications (Chrome, Instagram) and (b) capturing the full native call-back behavior of the XCorpus suite programs.},
	numpages     = 13,
	keywords     = {binary, static analysis, native code, Java}
}
@inproceedings{10.1145/3510003.3510135,
	title        = {Difuzer: Uncovering Suspicious Hidden Sensitive Operations in Android Apps},
	author       = {J. Samhi and L. Li and T. F. Bissyande and J. Klein},
	year         = 2022,
	month        = may,
	booktitle    = {2022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)},
	publisher    = {IEEE Computer Society},
	address      = {Los Alamitos, CA, USA},
	pages        = {723--735},
	doi          = {10.1145/3510003.3510135},
	url          = {https://doi.ieeecomputersociety.org/10.1145/3510003.3510135},
	keywords     = {support vector machines;weapons;instruments;prototypes;static analysis;feature extraction;internet}
}
@inproceedings{10.1145/3510003.3512766,
	title        = {JuCify: A Step Towards Android Code Unification for Enhanced Static Analysis},
	author       = {Samhi, Jordan and Gao, Jun and Daoudi, Nadia and Graux, Pierre and Hoyez, Henri and Sun, Xiaoyu and Allix, Kevin and Bissyand{\'e}, Tegawend{\'e} F and Klein, Jacques},
	year         = 2022,
	month        = may,
	booktitle    = {2022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)},
	publisher    = {IEEE Computer Society},
	address      = {Los Alamitos, CA, USA},
	pages        = {1232--1244},
	doi          = {10.1145/3510003.3512766},
	url          = {https://doi.ieeecomputersociety.org/10.1145/3510003.3512766},
	keywords     = {java;analytical models;codes;buildings;static analysis;malware;libraries}
}
@inproceedings{10.1145/3524842.3528020,
	title        = {TriggerZoo: A Dataset of Android Applications Automatically  Infected with Logic Bombs},
	author       = {J. Samhi and T. F. Bissyande and J. Klein},
	year         = 2022,
	month        = may,
	booktitle    = {2022 IEEE/ACM 19th International Conference on Mining Software Repositories (MSR)},
	publisher    = {IEEE Computer Society},
	address      = {Los Alamitos, CA, USA},
	pages        = {459--463},
	doi          = {10.1145/3524842.3528020},
	url          = {https://doi.ieeecomputersociety.org/10.1145/3524842.3528020},
	keywords     = {data privacy;runtime;codes;weapons;malware;behavioral sciences;internet}
}
@inbook{10.1145/353171.353189,
	title        = {Practical Virtual Method Call Resolution for Java},
	author       = {Sundaresan, Vijay and Hendren, Laurie and Razafimahefa, Chrislain and Vall\'{e}e-Rai, Raja and Lam, Patrick and Gagnon, Etienne and Godin, Charles},
	year         = 2000,
	booktitle    = {Proceedings of the 15th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	pages        = {264–280},
	isbn         = {158113200X},
	url          = {https://doi.org/10.1145/353171.353189},
	abstract     = {This paper addresses the problem of resolving virtual method and interface calls in Java bytecode. The main focus is on a new practical technique that can be used to analyze large applications. Our fundamental design goal was to develop a technique that can be solved with only one iteration, and thus scales linearly with the size of the program, while at the same time providing more accurate results than two popular existing linear techniques, class hierarchy analysis and rapid type analysis.We present two variations of our new technique, variable-type analysis and a coarser-grain version called declared-type analysis. Both of these analyses are inexpensive, easy to implement, and our experimental results show that they scale linearly in the size of the program.We have implemented our new analyses using the Soot frame-work, and we report on empirical results for seven benchmarks. We have used our techniques to build accurate call graphs for complete applications (including libraries) and we show that compared to a conservative call graph built using class hierarchy analysis, our new variable-type analysis can remove a significant number of nodes (methods) and call edges. Further, our results show that we can improve upon the compression obtained using rapid type analysis.We also provide dynamic measurements of monomorphic call sites, focusing on the benchmark code excluding libraries. We demonstrate that when considering only the benchmark code, both rapid type analysis and our new declared-type analysis do not add much precision over class hierarchy analysis. However, our finer-grained variable-type analysis does resolve significantly more call sites, particularly for programs with more complex uses of objects.},
	numpages     = 17
}
@article{10.1145/354222.353189,
	title        = {Practical Virtual Method Call Resolution for Java},
	author       = {Sundaresan, Vijay and Hendren, Laurie and Razafimahefa, Chrislain and Vall\'{e}e-Rai, Raja and Lam, Patrick and Gagnon, Etienne and Godin, Charles},
	year         = 2000,
	month        = oct,
	journal      = {ACM SIGPLAN NOTICES},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 35,
	number       = 10,
	pages        = {264–280},
	doi          = {10.1145/354222.353189},
	issn         = {0362-1340},
	url          = {https://doi.org/10.1145/354222.353189},
	issue_date   = {Oct. 2000},
	abstract     = {This paper addresses the problem of resolving virtual method and interface calls in Java bytecode. The main focus is on a new practical technique that can be used to analyze large applications. Our fundamental design goal was to develop a technique that can be solved with only one iteration, and thus scales linearly with the size of the program, while at the same time providing more accurate results than two popular existing linear techniques, class hierarchy analysis and rapid type analysis.We present two variations of our new technique, variable-type analysis and a coarser-grain version called declared-type analysis. Both of these analyses are inexpensive, easy to implement, and our experimental results show that they scale linearly in the size of the program.We have implemented our new analyses using the Soot frame-work, and we report on empirical results for seven benchmarks. We have used our techniques to build accurate call graphs for complete applications (including libraries) and we show that compared to a conservative call graph built using class hierarchy analysis, our new variable-type analysis can remove a significant number of nodes (methods) and call edges. Further, our results show that we can improve upon the compression obtained using rapid type analysis.We also provide dynamic measurements of monomorphic call sites, focusing on the benchmark code excluding libraries. We demonstrate that when considering only the benchmark code, both rapid type analysis and our new declared-type analysis do not add much precision over class hierarchy analysis. However, our finer-grained variable-type analysis does resolve significantly more call sites, particularly for programs with more complex uses of objects.},
	numpages     = 17
}
@article{10.1145/390013.808479,
	title        = {Control Flow Analysis},
	author       = {Allen, Frances E.},
	year         = 1970,
	month        = jul,
	journal      = {ACM SIGPLAN NOTICES},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 5,
	number       = 7,
	pages        = {1–19},
	doi          = {10.1145/390013.808479},
	issn         = {0362-1340},
	url          = {https://doi.org/10.1145/390013.808479},
	issue_date   = {July 1970},
	abstract     = {Any static, global analysis of the expression and data relationships in a program requires a knowledge of the control flow of the program. Since one of the primary reasons for doing such a global analysis in a compiler is to produce optimized programs, control flow analysis has been embedded in many compilers and has been described in several papers. An early paper by Prosser [5] described the use of Boolean matrices (or, more particularly, connectivity matrices) in flow analysis. The use of “dominance” relationships in flow analysis was first introduced by Prosser and much expanded by Lowry and Medlock [6]. References [6,8,9] describe compilers which use various forms of control flow analysis for optimization. Some recent developments in the area are reported in [4] and in [7].The underlying motivation in all the different types of control flow analysis is the need to codify the flow relationships in the program. The codification may be in connectivity matrices, in predecessor-successor tables, in dominance lists, etc. Whatever the form, the purpose is to facilitate determining what the flow relationships are; in other words to facilitate answering such questions as: is this an inner loop?, if an expression is removed from the loop where can it be correctly and profitably placed?, which variable definitions can affect this use?In this paper the basic control flow relationships are expressed in a directed graph. Various graph constructs are then found and shown to codify interesting global relationships.},
	numpages     = 19
}
@inproceedings{10.1145/800028.808479,
	title        = {Control Flow Analysis},
	author       = {Allen, Frances E.},
	year         = 1970,
	booktitle    = {Proceedings of a Symposium on Compiler Optimization},
	location     = {Urbana-Champaign, Illinois},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	pages        = {1–19},
	doi          = {10.1145/800028.808479},
	isbn         = 9781450373869,
	url          = {https://doi.org/10.1145/800028.808479},
	abstract     = {Any static, global analysis of the expression and data relationships in a program requires a knowledge of the control flow of the program. Since one of the primary reasons for doing such a global analysis in a compiler is to produce optimized programs, control flow analysis has been embedded in many compilers and has been described in several papers. An early paper by Prosser [5] described the use of Boolean matrices (or, more particularly, connectivity matrices) in flow analysis. The use of “dominance” relationships in flow analysis was first introduced by Prosser and much expanded by Lowry and Medlock [6]. References [6,8,9] describe compilers which use various forms of control flow analysis for optimization. Some recent developments in the area are reported in [4] and in [7].The underlying motivation in all the different types of control flow analysis is the need to codify the flow relationships in the program. The codification may be in connectivity matrices, in predecessor-successor tables, in dominance lists, etc. Whatever the form, the purpose is to facilitate determining what the flow relationships are; in other words to facilitate answering such questions as: is this an inner loop?, if an expression is removed from the loop where can it be correctly and profitably placed?, which variable definitions can affect this use?In this paper the basic control flow relationships are expressed in a directed graph. Various graph constructs are then found and shown to codify interesting global relationships.},
	numpages     = 19
}
@article{10.1214/aoms/1177730491,
	title        = {On a Test of Whether one of Two Random Variables is Stochastically Larger than the Other},
	author       = {Mann, H. B. and Whitney, D. R.},
	year         = 1947,
	month        = {03},
	journal      = {Annals of Mathematical Statistics},
	publisher    = {The Institute of Mathematical Statistics},
	volume       = 18,
	number       = 1,
	pages        = {50--60},
	doi          = {10.1214/aoms/1177730491},
	url          = {https://doi.org/10.1214/aoms/1177730491},
	fjournal     = {Annals of Mathematical Statistics}
}
@article{10.13140/2.1.2373.4080,
	title        = {Dynamic analysis of android malware},
	author       = {Van Der Veen, Victor and Bos, Herbert and Rossow, Christian},
	year         = 2013,
	journal      = {Internet \& Web Technology Master thesis, VU University Amsterdam},
	doi          = {10.13140/2.1.2373.4080}
}
@inproceedings{10.5555/1566770.1566773,
	title        = {Supervised Machine Learning: A Review of Classification Techniques},
	author       = {Kotsiantis, S. B.},
	year         = 2007,
	booktitle    = {Proceedings of the 2007 Conference on Emerging Artificial Intelligence Applications in Computer Engineering: Real Word AI Systems with Applications in EHealth, HCI, Information Retrieval and Pervasive Technologies},
	publisher    = {IOS Press},
	address      = {NLD},
	pages        = {3–24},
	isbn         = 9781586037802,
	abstract     = {The goal of supervised learning is to build a concise model of the distribution of class labels in terms of predictor features. The resulting classifier is then used to assign class labels to the testing instances where the values of the predictor features are known, but the value of the class label is unknown. This paper describes various supervised machine learning classification techniques. Of course, a single chapter cannot be a complete review of all supervised machine learning classification algorithms (also known induction classification algorithms), yet we hope that the references cited will cover the major theoretical issues, guiding the researcher in interesting research directions and suggesting possible bias combinations that have yet to be explored.},
	numpages     = 22,
	keywords     = {Classifiers, Intelligent Data Analysis, Data Mining, Learning Algorithms}
}
@article{10.1145/3395042,
	title        = {Fine-Grained Code Coverage Measurement in Automated Black-Box Android Testing},
	author       = {Pilgun, Aleksandr and Gadyatskaya, Olga and Zhauniarovich, Yury and Dashevskyi, Stanislav and Kushniarou, Artsiom and Mauw, Sjouke},
	year         = 2020,
	month        = {jul},
	journal      = {ACM Trans. Softw. Eng. Methodol.},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 29,
	number       = 4,
	doi          = {10.1145/3395042},
	issn         = {1049-331X},
	url          = {https://doi.org/10.1145/3395042},
	issue_date   = {October 2020},
	abstract     = {Today, there are millions of third-party Android applications. Some of them are buggy or even malicious. To identify such applications, novel frameworks for automated black-box testing and dynamic analysis are being developed by the Android community. Code coverage is one of the most common metrics for evaluating effectiveness of these frameworks. Furthermore, code coverage is used as a fitness function for guiding evolutionary and fuzzy testing techniques. However, there are no reliable tools for measuring fine-grained code coverage in black-box Android app testing.We present the Android Code coVerage Tool, ACVTool for short, that instruments Android apps and measures code coverage in the black-box setting at class, method and instruction granularity. ACVTool has successfully instrumented 96.9\% of apps in our experiments. It introduces a negligible instrumentation time overhead, and its runtime overhead is acceptable for automated testing tools. We demonstrate practical value of ACVTool in a large-scale experiment with Sapienz, a state-of-the-art automated testing tool. Using ACVTool on the same cohort of apps, we have compared different coverage granularities applied by Sapienz in terms of the found amount of crashes. Our results show that none of the applied coverage granularities clearly outperforms others in this aspect.},
	articleno    = 23,
	numpages     = 35,
	keywords     = {Android, code coverage, automated software testing, instrumentation}
}
@inproceedings{10.5555/1765931.1765948,
	title        = {Scaling Java Points-to Analysis Using SPARK},
	author       = {Lhot\'{a}k, Ond\v{r}ej and Hendren, Laurie},
	year         = 2003,
	booktitle    = {Proceedings of the 12th International Conference on Compiler Construction},
	location     = {Warsaw, Poland},
	publisher    = {Springer-Verlag},
	address      = {Berlin, Heidelberg},
	series       = {CC'03},
	pages        = {153–169},
	isbn         = 3540009043,
	abstract     = {Most points-to analysis research has been done on different systems by different groups, making it difficult to compare results, and to understand interactions between individual factors each group studied. Furthermore, points-to analysis for Java has been studied much less thoroughly than for C, and the tradeoffs appear very different. We introduce SPARK, a flexible framework for experimenting with points-to analyses for Java. SPARK supports equality- and subset-based analyses, variations in field sensitivity, respect for declared types, variations in call graph construction, off-line simplification, and several solving algorithms. SPARK is composed of building blocks on which new analyses can be based.We demonstrate SPARK in a substantial study of factors affecting precision and efficiency of subset-based points-to analyses, including interactions between these factors. Our results show that SPARK is not only flexible and modular, but also offers superior time/space performance when compared to other points-to analysis implementations.},
	numpages     = 17
}
@inproceedings{10.5555/1855741.1855756,
	title        = {KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs},
	author       = {Cadar, Cristian and Dunbar, Daniel and Engler, Dawson},
	year         = 2008,
	booktitle    = {Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation},
	location     = {San Diego, California},
	publisher    = {USENIX Association},
	address      = {USA},
	series       = {OSDI'08},
	pages        = {209–224},
	abstract     = {We present a new symbolic execution tool, KLEE, capable of automatically generating tests that achieve high coverage on a diverse set of complex and environmentally-intensive programs. We used KLEE to thoroughly check all 89 stand-alone programs in the GNU COREUTILS utility suite, which form the core user-level environment installed on millions of Unix systems, and arguably are the single most heavily tested set of open-source programs in existence. KLEE-generated tests achieve high line coverage -- on average over 90\% per tool (median: over 94\%) -- and significantly beat the coverage of the developers' own hand-written test suite. When we did the same for 75 equivalent tools in the BUSYBOX embedded system suite, results were even better, including 100\% coverage on 31 of them.We also used KLEE as a bug finding tool, applying it to 452 applications (over 430K total lines of code), where it found 56 serious bugs, including three in COREUTILS that had been missed for over 15 years. Finally, we used KLEE to crosscheck purportedly identical BUSYBOX and COREUTILS utilities, finding functional correctness errors and a myriad of inconsistencies.},
	numpages     = 16
}
@inproceedings{10.5555/2534766.2534813,
	title        = {Effective Inter-Component Communication Mapping in Android with Epicc: An Essential Step towards Holistic Security Analysis},
	author       = {Octeau, Damien and McDaniel, Patrick and Jha, Somesh and Bartel, Alexandre and Bodden, Eric and Klein, Jacques and Le Traon, Yves},
	year         = 2013,
	booktitle    = {Proceedings of the 22nd USENIX Conference on Security},
	location     = {Washington, D.C.},
	publisher    = {USENIX Association},
	address      = {USA},
	series       = {SEC'13},
	pages        = {543–558},
	isbn         = 9781931971034,
	abstract     = {Many threats present in smartphones are the result of interactions between application components, not just artifacts of single components. However, current techniques for identifying inter-application communication are ad hoc and do not scale to large numbers of applications. In this paper, we reduce the discovery of inter-component communication (ICC) in smartphones to an instance of the Interprocedural Distributive Environment (IDE) problem, and develop a sound static analysis technique targeted to the Android platform. We apply this analysis to 1,200 applications selected from the Play store and characterize the locations and substance of their ICC. Experiments show that full specifications for ICC can be identified for over 93\% of ICC locations for the applications studied. Further the analysis scales well; analysis of each application took on average 113 seconds to complete. Epicc, the resulting tool, finds ICC vulnerabilities with far fewer false positives than the next best tool. In this way, we develop a scalable vehicle to extend current security analysis to entire collections of applications as well as the interfaces they export.},
	numpages     = 16
}
@inproceedings{10.5555/2671225.2671244,
	title        = {Barecloud: Bare-Metal Analysis-Based Evasive Malware Detection},
	author       = {Kirat, Dhilung and Vigna, Giovanni and Kruegel, Christopher},
	year         = 2014,
	booktitle    = {Proceedings of the 23rd USENIX Conference on Security Symposium},
	location     = {San Diego, CA},
	publisher    = {USENIX Association},
	address      = {USA},
	series       = {SEC'14},
	pages        = {287–301},
	isbn         = 9781931971157,
	abstract     = {The volume and the sophistication of malware are continuously increasing and evolving. Automated dynamic malware analysis is a widely-adopted approach for detecting malicious software. However, many recent malware samples try to evade detection by identifying the presence of the analysis environment itself, and refraining from performing malicious actions. Because of the sophistication of the techniques used by the malware authors, so far the analysis and detection of evasive malware has been largely a manual process. One approach to automatic detection of these evasive malware samples is to execute the same sample in multiple analysis environments, and then compare its behaviors, in the assumption that a deviation in the behavior is evidence of an attempt to evade one or more analysis systems. For this reason, it is important to provide a reference system (often called bare-metal) in which the malware is analyzed without the use of any detectable component.In this paper, we present BareCloud, an automated evasive malware detection system based on bare-metal dynamic malware analysis. Our bare-metal analysis system does not introduce any in-guest monitoring component into the malware execution platform. This makes our approach more transparent and robust against sophisticated evasion techniques. We compare the malware behavior observed in the bare-metal system with other popular malware analysis systems. We introduce a novel approach of hierarchical similarity-based malware behavior comparison to analyze the behavior of a sample in the various analysis systems. Our experiments show that our approach produces better evasion detection results compared to previous methods. BareCloud was able to automatically detect 5,835 evasive malware out of 110,005 recent samples.},
	numpages     = 15
}
@inproceedings{10.5555/2818754.2818767,
	title        = {Composite Constant Propagation: Application to Android Inter-Component Communication Analysis},
	author       = {Octeau, Damien and Luchaup, Daniel and Dering, Matthew and Jha, Somesh and McDaniel, Patrick},
	year         = 2015,
	booktitle    = {Proceedings of the 37th International Conference on Software Engineering - Volume 1},
	location     = {Florence, Italy},
	publisher    = {IEEE Press},
	series       = {ICSE '15},
	pages        = {77–88},
	isbn         = 9781479919345,
	abstract     = {Many program analyses require statically inferring the possible values of composite types. However, current approaches either do not account for correlations between object fields or do so in an ad hoc manner. In this paper, we introduce the problem of composite constant propagation. We develop the first generic solver that infers all possible values of complex objects in an interprocedural, flow and context-sensitive manner, taking field correlations into account. Composite constant propagation problems are specified using COAL, a declarative language. We apply our COAL solver to the problem of inferring Android Inter-Component Communication (ICC) values, which is required to understand how the components of Android applications interact. Using COAL, we model ICC objects in Android more thoroughly than the state-of-the-art. We compute ICC values for 460 applications from the Play store. The ICC values we infer are substantially more precise than previous work. The analysis is efficient, taking slightly over two minutes per application on average. While this work can be used as the basis for many whole-program analyses of Android applications, the COAL solver can also be used to infer the values of composite objects in many other contexts.},
	numpages     = 12
}
@inproceedings{10.5555/2818754.2818791,
	title        = {IccTA: Detecting Inter-Component Privacy Leaks in Android Apps},
	author       = {Li, Li and Bartel, Alexandre and Bissyand\'{e}, Tegawend\'{e} F. and Klein, Jacques and Le Traon, Yves and Arzt, Steven and Rasthofer, Siegfried and Bodden, Eric and Octeau, Damien and McDaniel, Patrick},
	year         = 2015,
	booktitle    = {Proceedings of the 37th International Conference on Software Engineering - Volume 1},
	location     = {Florence, Italy},
	publisher    = {IEEE Press},
	series       = {ICSE '15},
	pages        = {280–291},
	isbn         = 9781479919345,
	abstract     = {Shake Them All is a popular "Wallpaper" application exceeding millions of downloads on Google Play. At installation, this application is given permission to (1) access the Internet (for updating wallpapers) and (2) use the device microphone (to change background following noise changes). With these permissions, the application could silently record user conversations and upload them remotely. To give more confidence about how Shake Them All actually processes what it records, it is necessary to build a precise analysis tool that tracks the flow of any sensitive data from its source point to any sink, especially if those are in different components.Since Android applications may leak private data carelessly or maliciously, we propose IccTA, a static taint analyzer to detect privacy leaks among components in Android applications. IccTA goes beyond state-of-the-art approaches by supporting inter-component detection. By propagating context information among components, IccTA improves the precision of the analysis. IccTA outperforms existing tools on two benchmarks for ICC-leak detectors: DroidBench and ICC-Bench. Moreover, our approach detects 534 ICC leaks in 108 apps from MalGenome and 2,395 ICC leaks in 337 apps in a set of 15,000 Google Play apps.},
	numpages     = 12
}
@inproceedings{10.5555/2818754.2818808,
	title        = {Mining Apps for Abnormal Usage of Sensitive Data},
	author       = {Avdiienko, Vitalii and Kuznetsov, Konstantin and Gorla, Alessandra and Zeller, Andreas and Arzt, Steven and Rasthofer, Siegfried and Bodden, Eric},
	year         = 2015,
	booktitle    = {Proceedings of the 37th International Conference on Software Engineering - Volume 1},
	location     = {Florence, Italy},
	publisher    = {IEEE Press},
	series       = {ICSE '15},
	pages        = {426–436},
	isbn         = 9781479919345,
	abstract     = {What is it that makes an app malicious? One important factor is that malicious apps treat sensitive data differently from benign apps. To capture such differences, we mined 2,866 benign Android applications for their data flow from sensitive sources, and compare these flows against those found in malicious apps. We find that (a) for every sensitive source, the data ends up in a small number of typical sinks; (b) these sinks differ considerably between benign and malicious apps; (c) these differences can be used to flag malicious apps due to their abnormal data flow; and (d) malicious apps can be identified by their abnormal data flow alone, without requiring known malware samples. In our evaluation, our mudflow prototype correctly identified 86.4% of all novel malware, and 90.1% of novel malware leaking sensitive data.},
	numpages     = 11
}
@article{10.5555/311868.311872,
	title        = {Comparing Observed Bug and Productivity Rates for Java and C++},
	author       = {Phipps, Geoffrey},
	year         = 1999,
	month        = apr,
	journal      = {Software: Practice and Experience},
	publisher    = {John Wiley \& Sons, Inc.},
	address      = {USA},
	volume       = 29,
	number       = 4,
	pages        = {345–358},
	issn         = {0038-0644},
	issue_date   = {April 10, 1999},
	numpages     = 14,
	keywords     = {metrics, programming languages, Java, C++}
}
@inproceedings{10.5555/3241189.3241239,
	title        = {Transcend: Detecting Concept Drift in Malware Classification Models},
	author       = {Jordaney, Roberto and Sharad, Kumar and Dash, Santanu Kumar and Wang, Zhi and Papini, Davide and Nouretdinov, Ilia and Cavallaro, Lorenzo},
	year         = 2017,
	booktitle    = {Proceedings of the 26th USENIX Conference on Security Symposium},
	location     = {Vancouver, BC, Canada},
	publisher    = {USENIX Association},
	address      = {USA},
	series       = {SEC'17},
	pages        = {625–642},
	isbn         = 9781931971409,
	abstract     = {Building machine learning models of malware behavior is widely accepted as a panacea towards effective malware classification. A crucial requirement for building sustainable learning models, though, is to train on a wide variety of malware samples. Unfortunately, malware evolves rapidly and it thus becomes hard--if not impossible--to generalize learning models to reflect future, previously-unseen behaviors. Consequently, most malware classifiers become unsustainable in the long run, becoming rapidly antiquated as malware continues to evolve. In this work, we propose Transcend, a framework to identify aging classification models in vivo during deployment, much before the machine learning model's performance starts to degrade. This is a significant departure from conventional approaches that retrain aging models retrospectively when poor performance is observed. Our approach uses a statistical comparison of samples seen during deployment with those used to train the model, thereby building metrics for prediction quality. We show how Transcend can be used to identify concept drift based on two separate case studies on Android and Windows malware, raising a red flag before the model starts making consistently poor decisions due to out-of-date training.},
	numpages     = 18
}
@inproceedings{10.5555/647067.757010,
	title        = {Static Analysis of Binary Code to Isolate Malicious Behaviors},
	author       = {Bergeron, J. and Debbabi, Mourad and Erhioui, M. M. and Ktari, B\'{e}chir},
	year         = 1999,
	booktitle    = {Proceedings of the 8th Workshop on Enabling Technologies on Infrastructure for Collaborative Enterprises},
	publisher    = {IEEE Computer Society},
	address      = {USA},
	series       = {WETICE '99},
	pages        = {184–189},
	isbn         = {0769503659},
	abstract     = {In this paper, we address the problem of static slicing on binary executables for the purposes of the malicious code detection in COTS components. By operating directly on binary code without any assumption on the availability of source code, our approach is realistic and appropriate for the analysis of COTS software products. To be able to reason on such low-level code, we need a suite of program transformations that aim to get a high level imperative representation of the code. The intention is to significantly improve the analyzability while preserving the original semantics. Next, we apply slicing techniques to extract those code fragments that are critical from the security standpoint. Finally, these fragments are subjected to verification against behavioral specifications to statically decide whether they exhibit malicious behaviors or not.},
	numpages     = 6
}
@inproceedings{10.5555/781995.782008,
	title        = {Soot - a Java Bytecode Optimization Framework},
	author       = {Vall\'{e}e-Rai, Raja and Co, Phong and Gagnon, Etienne and Hendren, Laurie and Lam, Patrick and Sundaresan, Vijay},
	year         = 1999,
	booktitle    = {Proceedings of the 1999 Conference of the Centre for Advanced Studies on Collaborative Research},
	location     = {Mississauga, Ontario, Canada},
	publisher    = {IBM Press},
	series       = {CASCON '99},
	pages        = 13,
	abstract     = {This paper presents Soot, a framework for optimizing Java bytecode. The framework is implemented in Java and supports three intermediate representations for representing Java bytecode: Baf, a streamlined representation of bytecode which is simple to manipulate; Jimple, a typed 3-address intermediate representation suitable for optimization; and Grimp, an aggregated version of Jimple suitable for decompilation. We describe the motivation for each representation, and the salient points in translating from one representation to another.In order to demonstrate the usefulness of the framework, we have implemented intraprocedural and whole program optimizations. To show that whole program bytecode optimization can give performance improvements, we provide experimental results for 12 large benchmarks, including 8 SPECjvm98 benchmarks running on JDK 1.2 for GNU/Linuxtm. These results show up to 8\% improvement when the optimized bytecode is run using the interpreter and up to 21\% when run using the JIT compiler.}
}
@inproceedings{6118781,
	title        = {Benchmark Dalvik and Native Code for Android System},
	author       = {Lin, Cheng-Min and Lin, Jyh-Horng and Dow, Chyi-Ren and Wen, Chang-Ming},
	year         = 2011,
	booktitle    = {2011 Second International Conference on Innovations in Bio-inspired Computing and Applications},
	pages        = {320--323},
	doi          = {10.1109/IBICA.2011.85}
}
@inproceedings{6280226,
	title        = {A case study in open source software security and privacy: Android adware},
	author       = {Erturk, Emre},
	year         = 2012,
	booktitle    = {World Congress on Internet Security (WorldCIS-2012)},
	pages        = {189--191}
}
@inproceedings{6903792,
	title        = {Management of an academic HPC cluster: The UL experience},
	author       = {Varrette, Sébastien and Bouvry, Pascal and Cartiaux, Hyacinthe and Georgatos, Fotis},
	year         = 2014,
	booktitle    = {2014 International Conference on High Performance Computing \& Simulation (HPCS)},
	pages        = {959--967},
	doi          = {10.1109/HPCSim.2014.6903792}
}
@inproceedings{7223198,
	title        = {On the effectiveness of dynamic taint analysis for protecting against private information leaks on Android-based devices},
	author       = {Babil, Golam Sarwar and Mehani, Olivier and Boreli, Roksana and Kaafar, Mohamed-Ali},
	year         = 2013,
	booktitle    = {2013 International Conference on Security and Cryptography (SECRYPT)},
	pages        = {1--8}
}
@inproceedings{7582748,
	title        = {Deep learning code fragments for code clone detection},
	author       = {White, Martin and Tufano, Michele and Vendome, Christopher and Poshyvanyk, Denys},
	year         = 2016,
	booktitle    = {2016 31st IEEE/ACM International Conference on Automated Software Engineering (ASE)},
	pages        = {87--98}
}
@inproceedings{978-931971-95-9,
	title        = {Aurasium: Practical Policy Enforcement for Android Applications},
	author       = {Rubin Xu and Hassen Sa{\"\i}di and Ross Anderson},
	year         = 2012,
	month        = aug,
	booktitle    = {21st USENIX Security Symposium (USENIX Security 12)},
	publisher    = {USENIX Association},
	address      = {Bellevue, WA},
	pages        = {539--552},
	isbn         = {978-931971-95-9},
	url          = {https://www.usenix.org/conference/usenixsecurity12/technical-sessions/presentation/xu\%5Frubin}
}
@inproceedings{afonso2016going,
	title        = {Going native: Using a large-scale analysis of android apps to create a practical native-code sandboxing policy},
	author       = {Afonso, Vitor and Bianchi, Antonio and Fratantonio, Yanick and Doup{\'e}, Adam and Polino, Mario and de Geus, Paulo and Kruegel, Christopher and Vigna, Giovanni},
	year         = 2016,
	booktitle    = {The Network and Distributed System Security Symposium},
	pages        = {1--15}
}
@inproceedings{agrawal2012detecting,
	title        = {Detecting hidden logic bombs in critical infrastructure software},
	author       = {Agrawal, Hira and Alberi, James and Bahler, Lisa and Micallef, Josephine and Virodov, Alexandr and Magenheimer, Mark and Snyder, Shane and Debroy, Vidroha and Wong, Eric},
	year         = 2012,
	booktitle    = {International Conference on Information Warfare and Security. Academic Conferences International Limited},
	volume       = 1
}
@article{arzt2013susi,
	title        = {Susi: A tool for the fully automated classification and categorization of android sources and sinks},
	author       = {Arzt, Steven and Rasthofer, Siegfried and Bodden, Eric},
	year         = 2013,
	journal      = {University of Darmstadt},
	publisher    = {Citeseer}
}
@conference{balzarotti2010efficient,
	title        = {Efficient detection of split personalities in malware},
	author       = {Balzarotti, Davide and  Cova, Marco and  Karlberger, Christoph and  Kruegel, Christopher and  Kirda, Engin and  Vigna, Giovanni},
	year         = 2010,
	booktitle    = {NDSS 2010, 17th Annual Network and Distributed System Security Symposium, February 28th-March 3rd, 2010, San Diego, USA},
	address      = {San Diego},
	note         = {ISOC. Personal use of this material is permitted. The definitive version of this paper was published in NDSS 2010, 17th Annual Network and Distributed System Security Symposium, February 28th-March 3rd, 2010, San Diego, USA and is available at :},
	editor       = {ISOC}
}
@article{doi:10.1155/2015/479174,
	title        = {Detecting and Classifying Android Malware Using Static Analysis along with Creator Information},
	author       = {Hyunjae Kang and Jae-wook Jang and Aziz Mohaisen and Huy Kang Kim},
	year         = 2015,
	journal      = {International Journal of Distributed Sensor Networks},
	volume       = 11,
	number       = 6,
	pages        = 479174,
	doi          = {10.1155/2015/479174},
	url          = {https://doi.org/10.1155/2015/479174},
	eprint       = {https://doi.org/10.1155/2015/479174},
	abstract     = {Thousands of malicious applications targeting mobile devices, including the popular Android platform, are created every day. A large number of those applications are created by a small number of professional underground actors; however previous studies overlooked such information as a feature in detecting and classifying malware and in attributing malware to creators. Guided by this insight, we propose a method to improve the performance of Android malware detection by incorporating the creator's information as a feature and classify malicious applications into similar groups. We developed a system that implements this method in practice. Our system enables fast detection of malware by using creator information such as serial number of certificate. Additionally, it analyzes malicious behaviors and permissions to increase detection accuracy. The system also can classify malware based on similarity scoring. Finally, we showed detection and classification performance with 98\% and 90\% accuracy, respectively.}
}
@article{doi:10.1162/089976601750264965,
	title        = {Estimating the Support of a High-Dimensional Distribution},
	author       = {Schölkopf, Bernhard and Platt, John C. and Shawe-Taylor, John and Smola, Alex J. and Williamson, Robert C.},
	year         = 2001,
	journal      = {Neural Computation},
	volume       = 13,
	number       = 7,
	pages        = {1443--1471},
	doi          = {10.1162/089976601750264965},
	url          = {https://doi.org/10.1162/089976601750264965},
	eprint       = {https://doi.org/10.1162/089976601750264965},
	abstract     = {Suppose you are given some data set drawn from an underlying probability distribution P and you want to estimate a “simple” subset S of input space such that the probability that a test point drawn from P lies outside of S equals some a priori specified value between 0 and 1. We propose a method to approach this problem by trying to estimate a function f that is positive on S and negative on the complement. The functional form of f is given by a kernel expansion in terms of a potentially small subset of the training data; it is regularized by controlling the length of the weight vector in an associated feature space. The expansion coefficients are found by solving a quadratic programming problem, which we do by carrying out sequential optimization over pairs of input patterns. We also provide a theoretical analysis of the statistical performance of our algorithm. The algorithm is a natural extension of the support vector algorithm to the case of unlabeled data.}
}
@book{forman2004java,
	title        = {Java reflection in action},
	author       = {Forman, Ira R and Forman, Nate and Ibm, John Vlissides},
	year         = 2004,
	publisher    = {Citeseer}
}
@inproceedings{10.1109/DSN.2012.6263963,
	title        = {An empirical study of the robustness of Inter-component Communication in Android},
	author       = {Maji, Amiya K. and Arshad, Fahad A. and Bagchi, Saurabh and Rellermeyer, Jan S.},
	year         = 2012,
	booktitle    = {IEEE/IFIP International Conference on Dependable Systems and Networks (DSN 2012)},
	volume       = {},
	number       = {},
	pages        = {1--12},
	doi          = {10.1109/DSN.2012.6263963}
}
@inproceedings{gordon2015information,
	title        = {Information flow analysis of android applications in droidsafe.},
	author       = {Gordon, Michael I and Kim, Deokhwan and Perkins, Jeff H and Gilham, Limei and Nguyen, Nguyen and Rinard, Martin C},
	year         = 2015,
	booktitle    = {NDSS},
	volume       = 15,
	pages        = 110
}
@techreport{hal-00700319,
	title        = {Improving privacy on android smartphones through in-vivo bytecode instrumentation},
	author       = {Bartel, Alexandre and Klein, Jacques and Monperrus, Martin and Allix, Kevin and Le Traon, yves},
	year         = 2012,
	number       = {arXiv:1208.4536},
	url          = {https://hal.archives-ouvertes.fr/hal-00700319},
	type         = {Research Report},
	institution  = {{University of Luxembourg}},
	keywords     = {in-vivo bytecode manipulation ; application level user-centric security policy ; privacy ; bytecode monitoring ; static analysis ; android},
	pdf          = {https://hal.archives-ouvertes.fr/hal-00700319/file/article.pdf},
	hal_id       = {hal-00700319},
	hal_version  = {v1}
}
@article{10.1145/3440033,
	title        = {Taming Reflection: An Essential Step Toward Whole-program Analysis of Android Apps},
	author       = {Sun, Xiaoyu  and Li, Li and Bissyandé, Tegawendé F.  and Klein, Jacques and Octeau, Damien and Grundy, John},
	year         = 2021,
	journal      = {ACM Trans. Softw. Eng. Methodol.},
	volume       = 30,
	number       = 3,
	pages        = 36,
	doi          = {https://doi.org/10.1145/3440033}
}
@inproceedings{cao2015edgeminer,
	title        = {EdgeMiner: Automatically Detecting Implicit Control Flow Transitions through the Android Framework.},
	author       = {Cao, Yinzhi and Fratantonio, Yanick and Bianchi, Antonio and Egele, Manuel and Kruegel, Christopher and Vigna, Giovanni and Chen, Yan},
	year         = 2015,
	booktitle    = {NDSS}
}
@inproceedings{10.1109/ASE.2015.76,
	title        = {Static Window Transition Graphs for Android},
	author       = {Yang, Shengqian and Zhang, Hailong and Wu, Haowei and Wang, Yan and Yan, Dacong and Rountev, Atanas},
	year         = 2015,
	booktitle    = {Proceedings of the 30th IEEE/ACM International Conference on Automated Software Engineering},
	location     = {Lincoln, Nebraska},
	publisher    = {IEEE Press},
	series       = {ASE '15},
	pages        = {658–668},
	doi          = {10.1109/ASE.2015.76},
	isbn         = 9781509000241,
	url          = {https://doi.org/10.1109/ASE.2015.76},
	abstract     = {This work develops a static analysis to create a model of the behavior of an Android application's GUI. We propose the window transition graph (WTG), a model representing the possible GUI window sequences and their associated events and callbacks. A key component and contribution of our work is the careful modeling of the stack of currently-active windows, the changes to this stack, and the effects of callbacks related to these changes. To the best of our knowledge, this is the first detailed study of this important static analysis problem for Android. We develop novel analysis algorithms for WTG construction and traversal, based on this modeling of the window stack. We also describe an application of the WTG for GUI test generation, using path traversals. The evaluation of the proposed algorithms indicates their effectiveness and practicality.},
	numpages     = 11
}
@inproceedings{10.1109/ICSE.2019.00070,
	title        = {StoryDroid: Automated Generation of Storyboard for Android Apps},
	author       = {Chen, Sen and Fan, Lingling and Chen, Chunyang and Su, Ting and Li, Wenhe and Liu, Yang and Xu, Lihua},
	year         = 2019,
	booktitle    = {2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)},
	pages        = {596--607},
	doi          = {10.1109/ICSE.2019.00070}
}
@inproceedings{10.1109/ICSE.2015.31,
	title        = {Static Control-Flow Analysis of User-Driven Callbacks in Android Applications},
	author       = {Yang, Shengqian and Yan, Dacong and Wu, Haowei and Wang, Yan and Rountev, Atanas},
	year         = 2015,
	booktitle    = {2015 IEEE/ACM 37th IEEE International Conference on Software Engineering},
	volume       = 1,
	number       = {},
	pages        = {89--99},
	doi          = {10.1109/ICSE.2015.31}
}
@article{10.1109/TSE.2016.2547385,
	title        = {Light-Weight, Inter-Procedural and Callback-Aware Resource Leak Detection for Android Apps},
	author       = {Wu, Tianyong and Liu, Jierui and Xu, Zhenbo and Guo, Chaorong and Zhang, Yanli and Yan, Jun and Zhang, Jian},
	year         = 2016,
	journal      = {IEEE Transactions on Software Engineering},
	volume       = 42,
	number       = 11,
	pages        = {1054--1076},
	doi          = {10.1109/TSE.2016.2547385}
}
@article{kan2019automated,
	title        = {Automated deobfuscation of Android native binary code},
	author       = {Kan, Zeliang and Wang, Haoyu and Wu, Lei and Guo, Yao and Luo, Daniel Xiapu},
	year         = 2019,
	journal      = {arXiv preprint}
}
@article{kim2012scandal,
	title        = {ScanDal: Static analyzer for detecting privacy leaks in android applications},
	author       = {Kim, Jinyung and Yoon, Yongho and Yi, Kwangkeun and Shin, Junbum and Center, SWRD},
	year         = 2012,
	journal      = {MoST},
	publisher    = {Citeseer},
	volume       = 12,
	number       = 110,
	pages        = 1
}
@inproceedings{lee2017learning,
	title        = {Learning binary code with deep learning to detect software weakness},
	author       = {Lee, Young Jun and Choi, Sang-Hoon and Kim, Chulwoo and Lim, Seung-Ho and Park, Ki-Woong},
	year         = 2017,
	booktitle    = {KSII The 9th International Conference on Internet (ICONI) 2017 Symposium}
}
@inproceedings{nan2018finding,
	title        = {Finding Clues for Your Secrets: Semantics-Driven, Learning-Based Privacy Discovery in Mobile Apps.},
	author       = {Nan, Yuhong and Yang, Zhemin and Wang, Xiaofeng and Zhang, Yuan and Zhu, Donglai and Yang, Min},
	year         = 2018,
	booktitle    = {NDSS}
}
@inproceedings{pan2017dark,
	title        = {Dark Hazard: Learning-based, Large-Scale Discovery of Hidden Sensitive Operations in Android Apps},
	author       = {Pan, Xiaorui and Wang, Xueqiang and Duan, Yue and Wang, XiaoFeng and Yin, Heng},
	year         = 2017,
	booktitle    = {NDSS}
}
@phdthesis{RizzoPhd,
	title        = {Static Flow Analysis for Hybrid and Native Android Applications},
	author       = {Claudio Rizzo},
	year         = 2020,
	abstract     = {Android applications consist of different components, interacting with each other, developed in different programming languages. While Java is at the core of an Android app, it may require to interact with the web or perform low-level Operating System (OS) operations. For example, Android Webviews are in-app browsers that expose interfaces to the JavaScript in the web page loaded to communicate with Java. Similarly, Android supports native code components that Java invokes via the Java Native Interface (JNI) framework. The ways of interaction of these components may introduce new security concerns the analyses need to address. Unfortunately, work so far has not addressed these mechanisms, compromising on precision and leaving potential security-critical bugs undiscovered.In this thesis, we propose new techniques to enable existing analyses to consider the multi-language nature of an Android application. First, we focus on Android Webviews. To this end, we developed BabelView, a tool that uses information flow analysis to assess the security of Web- views. Our idea is that we can make reasoning about JavaScript semantics unnecessary by instrumenting the application with a model of possible attacker behavior – the BabelView. We evaluated our approach on a sample of 25,000 apps from the Google Play Store, finding 10,808 potential vulnerabilities in 4,997 apps, having over 3 billion installations worldwide. We manually validated BabelView on a sample of 50 apps and estimated our fully automated analysis achieves a precision of 81\% at a recall of 89\%.Second, we focus on enabling analyses for Android native code. We created a new framework, JniFuzzer, which enables fuzzing for Android JNIs. We used JniFuzzer on real-world Android apps, finding potential vulnerabilities that we report as case studies. We then developed TaintSaviour, a Proof of Concept (PoC) tool which uses a black-box approach to generate summaries for JNIs. We implemented TaintSaviour as a plug-in of JniFuzzer, and we present a preliminary evaluation showing that our approach is viable and practical.},
	keywords     = {Android, Static Analysis, Information Security, Computer Security, Computer Science, WebView, JNI},
	institution  = {Royal Holloway, University of London},
	language     = {English},
	school       = {Royal Holloway -- University of London}
}
@inproceedings{tam2015copperdroid,
	title        = {Copperdroid: Automatic reconstruction of android malware behaviors},
	author       = {Tam, Kimberly and Khan, Salahuddin J and Fattori, Aristide and Cavallaro, Lorenzo},
	year         = 2015,
	booktitle    = {Ndss}
}
@inproceedings{10.1145/199448.199462,
	title        = {Precise Interprocedural Dataflow Analysis via Graph Reachability},
	author       = {Reps, Thomas and Horwitz, Susan and Sagiv, Mooly},
	year         = 1995,
	booktitle    = {Proceedings of the 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
	location     = {San Francisco, California, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {POPL '95},
	pages        = {49–61},
	doi          = {10.1145/199448.199462},
	isbn         = {0897916921},
	url          = {https://doi.org/10.1145/199448.199462},
	abstract     = {The paper shows how a large class of interprocedural dataflow-analysis problems can be solved precisely in polynomial time by transforming them into a special kind of graph-reachability problem. The only restrictions are that the set of dataflow facts must be a finite set, and that the dataflow functions must distribute over the confluence operator (either union or intersection). This class of probable problems includes—but is not limited to—the classical separable problems (also known as “gen/kill” or “bit-vector” problems)—e.g., reaching definitions, available expressions, and live variables. In addition, the class of problems that our techniques handle includes many non-separable problems, including truly-live variables, copy constant propagation, and possibly-uninitialized variables.Results are reported from a preliminary experimental study of C programs (for the problem of finding possibly-uninitialized variables).},
	numpages     = 13
}
@article{vallee1998jimple,
	title        = {Jimple: Simplifying Java bytecode for analyses and transformations},
	author       = {Vallee-Rai, Raja and Hendren, Laurie J},
	year         = 1998,
	journal      = {no},
	publisher    = {Citeseer}
}
@article{xu2009robustness,
	title        = {Robustness and Regularization of Support Vector Machines.},
	author       = {Xu, Huan and Caramanis, Constantine and Mannor, Shie},
	year         = 2009,
	journal      = {Journal of machine learning research},
	volume       = 10,
	number       = 7
}
